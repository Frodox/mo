% создаем документ типа "отчет"
\documentclass[a4paper,12pt]{report}
% фишки для набора формул
\usepackage{amsmath,amssymb}
% для вывода русских символов задаем шрифты и кодировки
\usepackage[OT2,T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{pscyr}
% рулим полями страницы
\usepackage[top=2cm, bottom=2cm, left=2cm, right=1.5cm]{geometry}
% включаем возможность создания длинных таблиц, которые находятся на нескольких листах
\usepackage{longtable}
% рулим header-ами и footer-ами
\usepackage{fancyhdr}
% включаем возможность copy-paste из PDF
\usepackage{cmap}
% для абзацных отступов (красная строка)
\usepackage{indentfirst}
% в России после номера таблицы ставится точка, а не двоеточие, поэтому нужен этот пакет
\usepackage[font=footnotesize,labelsep=period,skip=0pt,singlelinecheck=false,center]{caption}
% нужно для ввода в таблицы инструкции m{..} - позволяет центрировать по вертикали содержимое ячеек
\usepackage{array}
% нужно для аналогов rowspan в HTML
\usepackage{multirow}
% косая черта в ячейке таблицы
\usepackage{slashbox}
% ссылки в тексте документа
\usepackage[colorlinks,filecolor=black,citecolor=black,linkcolor=black,unicode]{hyperref}
% вставка рисунков
\usepackage{graphicx}
% относительный путь до каталога с рисунками
\graphicspath{{img/}}

\bibliographystyle{unsrt} % стиль библиографических ссылок БибТеХа

\newcommand{\docTitle}{Методы оптимизации}
\newcommand{\docVersion}{0.1}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % своя команда для рисования линий на титульной странице

\renewcommand{\theenumi}{\arabic{enumi}} % меняем везде перечисления на цифра.цифра
\renewcommand{\baselinestretch}{1.25} % делаем полуторный интервал

% переопределяем стиль страницы с собственными header-ами и footer-ами
\fancypagestyle{plain}
{
  \lhead{\textbf{\docTitle} (текст лекций)} % слева в header-е название документа
  \chead{}
  \rhead{\emph{Версия:} \docVersion} % справа в header-е номер версии
  \lfoot{}
  \cfoot{}
  \rfoot{\thepage} % справа в footer-е номер страницы
  \renewcommand{\headrulewidth}{0.4pt} % отчеркивание для header-а
  \renewcommand{\footrulewidth}{0.4pt} % отчеркивание для footer-а
}

\begin{document}

\begin{titlepage}

\begin{center}

% Разработчик
\textsc{\LARGE Прудников А.М.}\\[7.0cm]

% Общий заголовок
\textsc{\Large Текст лекций по курсу}\\[0.5cm]

% Заголовок конкретного документа
\HRule \\[0.4cm]
{ \huge \bfseries \docTitle}\\[0.4cm]

\HRule \\[1.5cm]

% Редакция
\begin{minipage}{0.8\textwidth}
\begin{flushright} \large
\emph{Версия:} \docVersion
\end{flushright}
\end{minipage}

\vfill

% Дата
{\large Москва, 2012}

\end{center}

\end{titlepage}

\setcounter{page}{2}

\pagestyle{plain}

\clearpage

\tableofcontents

\clearpage

\chapter{Понятие математической оптимизации}

\section{Исследование операций и место методов оптимизации в данной дисциплине}

\textbf{Исследование операций} – математическая дисциплина, занимающаяся построением, разработкой и применением математических моделей принятия оптимальных решений во всех областях человеческой деятельности.

\textbf{Операция} – это всякое мероприятие (система действий), объединенное единым замыслом и направленное к достижению какой-то цели.

Пусть необходимо выполнить какое-либо мероприятие для достижения определенной цели (\textbf{операцию}). Обычно существует свобода выбора в том, как это мероприятие организовать 
(например, выбор техники, распределение ресурсов и т.д.). \textbf{<<Решение>>} – это какой-то выбор из ряда допустимых возможностей.

Краеугольным камнем исследования операций является \textbf{математическое моделирование}. Данные, полученные при исследовании математических моделей, являются основой для принятия решений. 
Но общих способов построения математических моделей и методов их решения не существует. В каждом конкретном случае модель выбирается исходя из вида операции, ее целевой направленности, 
с учетом задачи исследования.

Наиболее известными методами исследования операций (являющимися, зачастую, самостоятельными математическими дисциплинами), являются:
\begin{itemize}
\item Математическое программирование – теория и методы решения задач о нахождении экстремумов функций на множествах векторного пространства, определяемых линейными и нелинейными ограничениями 
(равенствами и неравенствами). (Присутствие в названии термина <<программирование>> объясняется тем, что первые исследования оптимизационных задач были в сфере экономики, а в английском языке 
слово <<programming>> означает планирование, составление планов или программ).
\item Сетевые модели – решение оптимизационных задач с использованием графов.
\item Марковские процессы – метод решения стохастических задач, где процесс принятия решений можно представить конечным числом состояний.
\item Теория игр – методы изучения оптимальных стратегий в играх. Теория игр помогает выбрать лучшие стратегии с учётом представлений о других участниках, их ресурсах и их возможных поступках.
\item Теория массового обслуживания (теория очередей) – раздел теории вероятностей, целью исследований которого является рациональный выбор структуры системы обслуживания и процесса обслуживания на 
основе изучения потоков требований на обслуживание, длительности ожидания и длины очередей.
\item Имитационное моделирование – метод исследования, при котором изучаемая система заменяется компьютерной моделью, с достаточной точностью описывающей реальную систему, и с ней проводятся эксперименты 
с целью получения информации об этой системе. Экспериментирование с моделью называют имитацией.
\end{itemize}

В данном курсе будет изучаться математическое программирование, методы которого и являются так называемыми \textbf{методами оптимизации}.

\section{Понятие оптимизации}
Оптимизация в самом широком смысле - это выбор наилучшего варианта из множества возможных. Рассмотрим некоторые классические примеры оптимизационных задач.

\subsection{Задача коммивояжера}
Дано некоторое количество городов и расстояния между ними. Коммивояжер должен посетить каждый город и вернуться к месту отправления. Какой маршрут он должен выбрать? Зададим расстояния между городами (допустим, их пять) в виде следующей таблицы:

\begin{center}
\begin{tabular}{|l|>{$}c<{$}|>{$}c<{$}|>{$}c<{$}|>{$}c<{$}|>{$}c<{$}|>{$}c<{$}|}
\hline
\backslashbox{}{} & 1 & 2 & 3 & 4 & 5\\
\hline
1 & - & 1 & 7 & 2 & 8\\
\hline
2 & 2 & - & 10 & 3 & 1\\
\hline
3 & 7 & 10 & - & 2 & 6\\
\hline
4 & 2 & 3 & 2 & - & 4\\
\hline
5 & 8 & 1 & 6 & 4 & -\\
\hline
\end{tabular}
\end{center}

Проложим несколько маршрутов и посчитаем расстояние для них:
\begin{itemize}
\item Маршрут \(5 \rightarrow 1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5\), расстояние \(8+1+10+2+4=25\)
\item Маршрут \(5 \rightarrow 2 \rightarrow 1 \rightarrow 4 \rightarrow 3 \rightarrow 5\), расстояние \(1+1+2+2+6=12\)
\end{itemize}

Каким же образом (исключая полный перебор) следует выбрать кратчайший маршрут?

\subsection{Задача размещения производства}
\label{sec:ZRP}
Пусть в некотором регионе имеется ряд потребителей некоторой продукции. Нужно определить, как разместить в этом регионе заводы по производству данной продукции.

Существует два крайних решения:
\begin{enumerate}
\item Можно разместить только один завод; в этом случае производственные затраты будут минимальны, но станут максимальными затраты на доставку продукции потребителям (транспортные затраты).
\item Можно разместить большое количество заводов (рядом с каждым потребителем); в этом случае транспортные затраты будут минимальны, но станут максимальными производственные затраты.
\end{enumerate}

Очевидно, что оптимальное решение заключается в минимизации суммарных затрат \(C_{\text{общ}} = C_{\text{произв}} + C_{\text{трансп}} \rightarrow \min\).

\subsection{Построение математической модели}
Как было сказано выше, для решения любых задач исследования операций (и, соответственно, задач математического программирования) необходимо формализовать решаемую задачу, построив ее математическую модель. В самых общих чертах процесс построения математической модели можно представить следующим образом:
\begin{enumerate} 
\item Определение неизвестных параметров (элементов решения).
\item Выражение условий задачи через введенные на первом шаге неизвестные.
\item Выбор критерия оптимальности.
\end{enumerate}

Попробуем выполнить описанные выше шаги для построения математической модели задачи размещения производства (см. раздел \ref{sec:ZRP}). 

На шаге \textbf{определения неизвестных параметров} введем переменные \(x_{ij}\) - объем перевозимой продукции с \(i\)-го завода \(j\)-му потребителю; здесь \(i=\overline{1,m}\) - количество заводов, \(j=\overline{1,n}\) - количество потребителей. 

Теперь \textbf{выразим условия задачи} через эти переменные:
\begin{enumerate}
\item Очевидно, что количество перевозимой продукции не может быть отрицательно: \(x_{ij}\geq 0\).
\item Если обозначить известный нам объем заказов (потребления) продукции \(j\)-м потребителем через \(b_{j}\), то на объем перевозок можно наложить ограничение \(\sum\limits_{i=1}^m x_{ij} = b_{j}\) (не следует везти к потребителю продукции больше, чем он заказывает).
\item Если обозначить известные нам удельные транспортные затраты на перевозку изделий от \(i\)-го завода \(j\)-му потребителю через \(c_{ij}\), то можно составить уравнение для транспортных затрат: \(C_{\text{трансп}} = \sum\limits_{i=1}^m \sum\limits_{j=1}^n c_{ij}x_{ij}\).
\item Если обозначить известную нам стоимость производства на \(i\)-ом заводе (которая, вообще говоря, зависит от объемов производства) через \(f_{i}(x_{i})\), то можно составить уравнение для производственных затрат: \(C_{\text{произв}} = \sum\limits_{i=1}^m f_{i}(\sum\limits_{j=1}^n x_{ij})\).
\end{enumerate}
Осталось \textbf{выбрать критерий оптимальности}, однако это мы уже сделали в п. \ref{sec:ZRP}: суммарные затраты должны быть минимальны.

Таким образом, в результате формализации задачи мы построили ее математическую оптимизационную модель следующего вида:

\begin{equation}
\label{eq:num1}
\min \left\{\sum\limits_{i=1}^m f_{i}(\sum\limits_{j=1}^n x_{ij}) + \sum\limits_{i=1}^m \sum\limits_{j=1}^n c_{ij}x_{ij}\right\}
\end{equation}
при ограничениях
\begin{align}
\label{eq:num2}
\begin{cases}
\sum\limits_{i=1}^m x_{ij} = b_{j} \\
x_{ij} \geq 0
\end{cases}	
i=\overline{1,m}, j=\overline{1,n}
\end{align}

Опираясь на полученный результат, можно попробовать записать постановку оптимизационной задачи в общем виде.

\section{Общий вид однокритериальной оптимизационной задачи}

В общем виде задача математического программирования ставится следующим образом: найти максимум (минимум) функции 
\begin{equation}
\label{eq:num3}
f(x_{1}, x_{2}, \ldots, x_{n}) = f(\bar{x})	
\end{equation}
при ограничениях
\begin{align}
\label{eq:num4}
\begin{cases}
g_{i}(x_{1}, x_{2}, \ldots, x_{n}) \leq b_{i}, i=\overline{1,m} \\
x_{j} \geq 0, j=\overline{1,n}
\end{cases}	
\end{align}

Здесь:
\begin{itemize}
\item \(f(\bar{x})\) - целевая функция;
\item система неравенств и условия неотрицательности переменных \eqref{eq:num4} - система ограничений.
\end{itemize}

Всякое решение задачи с учетом системы ограничений называется \textbf{допустимым решением}. Допустимое решение, максимизирующее (минимизирующее) целевую функцию, называется \textbf{оптимальным решением}. Таким образом, задача математического программирования заключается в нахождении оптимального решения, которое по определению обеспечивает максимальное (минимальное) значение целевой функции с учетом заданных ограничений.

\section{Особенности задачи математического программирования}
\begin{enumerate}
\item Если требуется найти минимум \(f(\bar{x})\), то это эквивалентно поиску максимума \(-f(\bar{x})\).
\item В любом случае можно добиться условия неотрицательности переменных, то есть, если задано ограничение \(x_{j} \geq x_{j\_min}\), то можно сделать замену переменных \(x^{'}_{j} = x_{j} - x_{j\_min} \geq 0\).
\item Если заданы ограничения вида \(g_{i}(\bar{x}) \geq b_{i}\), то простой заменой знака приходим к первоначальной форме \(-g_{i}(\bar{x}) \leq -b_{i}\).
\item Функция \(f(\bar{x})\) может иметь несколько экстремумов, а именно локальные экстремумы и глобальный экстремум. Функция \(f(\bar{x})\), определенная на области \(D\), достигает на ней глобального максимума \(\bar{x}^{*} \in D\), если неравенство \(f(\bar{x}) \leq f(\bar{x}^{*})\) справедливо для любой точки \(\bar{x} \in D\). Функция \(f(\bar{x})\), определенная на области \(D\), достигает на ней локального максимума \(\bar{x}^{*} \in D\), если неравенство \(f(\bar{x}) \leq f(\bar{x}^{*})\) справедливо для точек из некоторой окрестности \(\bar{x}^{*}\).
\item В математическом анализе для нахождения экстремумов функций используются производные (это классические методы оптимизации). Такие методы применяют лишь для сравнительно простых задач из-за следующих недостатков:
\begin{itemize}
\item для использования таких методов нужно, чтобы функции \(f(\bar{x})\) и \(g_{i}(\bar{x})\) были непрерывны и имели частные производные по крайней мере до 2-го порядка;
\item с помощью классических методов можно найти экстремум только внутри области; если оптимальная точка находится на границе области, то эти методы бессильны;
\item на переменные \(x_{j}\) не должны быть наложены условия целочисленности.
\end{itemize}
\end{enumerate}

\section{Классификация задач математического программирования}
В зависимости от вида функций, входящих в критерий оптимальности и систему ограничений, а также допустимой области изменения переменных, задачи математического программирования разделяются на следующие классы:
\begin{enumerate}
\item Линейное программирование - целевая функция и ограничения являются линейными. Область допустимых значений - многогранник, а оптимальное решение находится в одной из его вершин.
\item Нелинейное программирование - или целевая функция, или какое-либо ограничение содержит нелинейную зависимость.
\item Дискретное программирование - переменные могут принимать только целочисленные значения.
\end{enumerate}

\section{Классификация методов решения задач оптимизации}
\label{sec:ClassMetOpt}
Особенность задач оптимизации состоит в том, что вычисление значений целевой функции и значений ограничивающих функций может требовать больших затрат времени. В связи с этим возникает проблема решения задач оптимизации при наименьшем числе испытаний.
\textbf{Испытанием} называется операция однократного вычисления функций \(f(\bar{x})\) и \(g_{i}(\bar{x})\) (и, в некоторых случаях, их производных) в некоторой точке \(\bar{x}\).
Далее будем говорить, что задача оптимизации решается с помощью \textbf{поискового метода оптимизации}, если используется следующая процедура поиска оптимального решения \(\bar{x}^{*}\):
\begin{itemize}
\item по очереди при \(r=0,1,2,\ldots,N-1\) производятся испытания в точках
\begin{equation}
\label{eq:num5}
\bar{x}^{r+1} = \Psi_{r+1}\left(\bar{x}^{0}, f(\bar{x}^{0}), g_{i}(\bar{x}^{0}),\ldots,\bar{x}^{r}, f(\bar{x}^{r}), g_{i}(\bar{x}^{r})\right)
\end{equation}
\item в качестве решения задачи берется точка \(\bar{x}^{*}\), которая находится из условия \(f(\bar{x}^{*})=\underset{r\in[0;N]}{\min}f(\bar{x}^{r})\).
\end{itemize}
Здесь:
\begin{itemize}
\item \(r\) - текущий номер испытания;
\item \(N\) - число испытаний;
\item \(\bar{x}^{0}\) - начальное приближение;
\item \(\Psi_{r}\) - алгоритм поисковой оптимизации на \(r\)-ом шаге.
\end{itemize}

В общем случае \textbf{алгоритмом поисковой оптимизации} называется способ выбора начального приближения \(\bar{x}^{0}\) и конкретная совокупность функций \(\left\{\Psi_{r}\right\}\). Таким образом, понятие алгоритма является более частным по сравнению с понятием метода (одному и тому же методу могут соответствовать разные алгоритмы).

Теперь проведем классификацию методов решения с учетом введенным понятий.

\begin{enumerate}
\item \textbf{Классификация по наличию или отсутствию системы ограничений}. Если в задаче отсутствует система ограничений, то она решается методами \textbf{безусловной} оптимизации; в противном случае - методами \textbf{условной} оптимизации.
\item \textbf{Классификация по размерности вектора \(\bar{x}\)}. Если \(\bar{x}\) на самом деле скаляр, то применяются \textbf{одномерные} методы оптимизации; в противном случае - \textbf{многомерные}.
\item \textbf{Классификация по характеру искомого решения}. Если метод поиска гарантирует отыскание только локального экстремума, то это метод \textbf{локальной} оптимизации. Если делается попытка отыскать глобальный экстремум, то это метод \textbf{глобальной} оптимизации. Следует отметить, что удовлетворительных с точки зрения вычислительной эффективности методов глобальной оптимизации не существует.
\item \textbf{Классификация по характеру функций \(\Psi_{r}\)}. Если функции \(\Psi_{r}\) являются детерминированными, то метод оптимизации называется \textbf{детерминированным}. Если же функции \(\Psi_{r}\) содержат случайные параметры, то метод оптимизации называется \textbf{стохастическим}.
\item \textbf{Классификация по способу выбора точек \(\bar{x}^{r}\)}. Если все точки \(\bar{x}^{r}\) назначаются заранее (до проведения испытаний), то метод оптимизации называется \textbf{пассивным}. Если же очередная точка \(\bar{x}^{r+1}\) определяется на основе всей или части информации об испытаниях в точках \(\bar{x}^{0},\ldots,\bar{x}^{r}\), то метод называется \textbf{последовательным}.
\item \textbf{Классификация по количеству предыдущих учитываемых шагов}. Если в последовательном методе при определении точки \(\bar{x}^{r+1}\) учитывается информация только о предыдущем испытании, то метод называется \textbf{одношаговым}. Если же используется информация о \(s > 1\) предыдущих испытаниях, то метод называется многошаговым (конкретнее, \(s\)-шаговым).
\item \textbf{Классификация по виду функций \(\Psi_{r}\)}. Если функция \(\Psi_{r}\) при всех \(N\) испытаниях одинакова, то метод называется \textbf{итерационным}. Если же функции \(\Psi_{r}\) меняются от испытания к испытанию, то метод является \textbf{неитерационным}.
\item \textbf{Классификация по порядку используемых производных}. Если при вычислении значений функций \(\Psi_{r}\) производные не используются, то метод называется \textbf{прямым} (или \textbf{нулевого порядка}). Если же используются производные \(k\)-го порядка, то метод называется методом \textbf{\(k\)-го порядка} (методы 1-го порядка также называются \textbf{градиентными}).
\end{enumerate}

\section{Условия окончания поиска}
Выбор условия (критерия) окончания поиска является еще одной важной проблемой при решении оптимизационных задач. Наиболее широко используемыми являются следующие критерии:
\begin{itemize}
\item \(\left\|\bar{x}^{r+1} - \bar{x}^{r}\right\| \leq \epsilon_{x}\), где \(\epsilon_{x}\) - требуемая точность решения по \(\bar{x}\), \(\left\|\cdot\right\|\) - некоторая векторная норма (например, евклидова);
\item \(\left|f(\bar{x}^{r+1}) - f(\bar{x}^{r})\right| \leq \epsilon_{f}\), где \(\epsilon_{f}\) - требуемая точность решения по \(f\).
\end{itemize}

\chapter{Нелинейное программирование}

\section{Безусловная оптимизация функций одной переменной}
Оптимизация функций одной переменной является, как правило, необходимым элементом методов оптимизации функций многих переменных. На первый взгляд кажется, что эта задача достаточно проста и решается с помощью дифференцирования (классический метод оптимизации). Однако для широкого класса функций это не так, поскольку задача решения уравнения \(f'(x) = 0\) может оказаться весьма сложной (или даже невозможной, если \(f(x)\) не дифференцируема).

Как уже было упомянуто выше, существование локальных экстремумов функции почти всегда затрудняет поиск глобального экстремума. Поэтому многие методы оптимизации применимы только тогда, когда любой локальный экстремум является одновременно и глобальным; это дает гарантию сходимости метода. Если же таких сведений о функции нет, то методы применять можно, но без гарантии сходимости.

Одним из классов функций, удовлетворяющих указанному условию, является класс \textbf{унимодальных (одноэкстремальных)} функций. Дадим определение такой функции для задачи поиска минимума (для задачи поиска максимума определение строится аналогичным образом).

Функция \(f(x)\) называется \textbf{унимодальной} на отрезке \(\left[a, b\right]\), если она непрерывна\footnote[1]{В общем случае это не так, но мы под унимодальной функцией будем подразумевать непрерывную унимодальную функцию.} на \(\left[a, b\right]\) и существуют такие \(\alpha\) и \(\beta\) (\(a \leq \alpha \leq \beta \leq b\)), что:
\begin{enumerate}
\item на отрезке \(\left[a, \alpha\right]\) при \(a < \alpha\) \(f(x)\) монотонно убывает;
\item на отрезке \(\left[\beta, b\right]\) при \(\beta < b\) \(f(x)\) монотонно возрастает;
\item существует минимум \(f(x)\) при \(x \in \left[\alpha, \beta\right]\).
\end{enumerate}
Примеры унимодальных функций приведены на рисунке \ref{fig:unimod_example}.

\newpage

\begin{figure}[ht]
\center{\includegraphics[width=0.8\linewidth]{unimod_example.png}}
\caption{Примеры унимодальных функций}
\label{fig:unimod_example}
\end{figure}

Прежде чем приступить к процедуре оптимизации, следует по возможности установить принадлежность целевой функции классу, для которого гарантирована сходимость процесса.

Заметим, что предположение об унимодальности функции в окрестности точки экстремума весьма естественно. Получение информации о таком промежутке является важным предварительным этапом процедуры оптимизации.

Рассмотрим с общих позиций ряд методов (разделы \ref{sec:PassiveSearch} и \ref{sec:PosledSearch}), позволяющих находить экстремумы (далее при рассмотрении алгоритмов будем говорить о задаче поиска минимума) унимодальных функций на отрезке \(\left[a, b\right]\). Эти методы объединяет идея сокращения \textbf{текущего интервала неопределенности (ТИН)}. Она состоит в том, что в процессе поиска исключаются из рассмотрения те подынтервалы, на которых точка оптимума \(x^{*}\) отсутствует в силу унимодальности целевой функции.

\subsection{Пассивные методы поиска}
\label{sec:PassiveSearch}
На практике подобные методы применяются, когда удобно провести независимые эксперименты по измерению значений функции \(f(x)\), а последовательное измерение этих значений трудоемко или невозможно по каким-либо причинам.

\subsubsection{Метод равномерного поиска}
Испытания проводятся в точках, которые определяются путем равномерного деления отрезка \(\left[a, b\right]\) на \(N\) одинаковых интервалов. Из вычисленных в узлах полученной сетки значений целевой функции выбирается наименьшее (пусть это значение достигается в некотором узле \(x_{k}\). Тогда, в связи с унимодальностью целевой функции, подынтервалы \(\left[a, x_{k-1}\right]\) и \(\left[x_{k+1}, b\right]\) можно исключить из рассмотрения, то есть сделать очередным ТИН отрезок \(\left[x_{k-1}, x_{k+1}\right]\).

\textbf{Алгоритм метода:}
\begin{enumerate}
\item Выполняем присваивание \(r = 1, a^{1} = a, b^{1} = b, \text{ТИН}_{1} = \left[a^{1}, b^{1}\right]\).
\item На очередном ТИН строим равномерную сетку с \(N + 1\) узлом.
\item Вычисляем значения целевой функции в узлах сетки.
\item Находим минимальное из вычисленных значений \(\min(f(x^{r}_{0}), f(x^{r}_{1}), \ldots, f(x^{r}_{N})) = f(x^{r}_{k})\).
\item Выполняем присваивание \(a^{r+1} = x^{r}_{k-1}, b^{r+1} = x^{r}_{k+1}, \text{ТИН}_{r+1} = \left[a^{r+1}, b^{r+1}\right]\).
\item Если \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), то заканчиваем вычисления; иначе выполняем присваивание \(r = r + 1\) и переходим к шагу 2.
\end{enumerate}
В качестве приближенного значения точки минимума \(x^{*}\) может быть принята любая точка последнего ТИН.

На рисунке \ref{fig:RavnomSearch} показан один шаг метода равномерного поиска при \(N = 13\).

Поскольку после каждой итерации длина ТИН уменьшается в фиксированное (\(\frac{N}{2}\)) количество раз, можно априорно оценить количество итераций по заданной точности решения. Действительно, после первой итерации \(\left|\text{ТИН}_{2}\right| = 2\frac{b-a}{N}\), после второй итерации \(\left|\text{ТИН}_{3}\right| = 2((2\frac{b-a}{N})/N) = (b-a)(\frac{2}{N})^{2}\) и т.д. Тогда после \(r\)-ой итерации имеем \(\left|\text{ТИН}_{r+1}\right| = (b-a)(\frac{2}{N})^{r}\). Но, так как условие окончания поиска \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), получаем \((b-a)(\frac{2}{N})^{r} \leq \epsilon_{x}\). Заменив знак неравенства на равенство и выразив \(r\), получим оценку количества итераций.

\subsubsection{Метод поразрядного поиска}
Можно усовершенствовать метод равномерного поиска, уменьшив количество вычислений значений целевой функции на каждой итерации. Во-первых, если \(f(x^{r}_{i}) < f(x^{r}_{i+1})\), то отпадает необходимость вычислять \(f(x)\) в точках \(x^{r}_{i+2}, x^{r}_{i+3}\) и т.д. Во-вторых, разумно было бы сначала грубо определить отрезок, содержащий оптимальную точку; а затем на этом отрезке искать ее с меньшим шагом дискретизации. Иными словами, следует сделать шаг сетки не постоянным, а зависящим от итерации.

В методе поразрядного поиска перебор точек происходит с некоторым шагом \(h_{r}\) до тех пор, пока не выполнится условие \(f(x^{r}_{i}) < f(x^{r}_{i+1})\), или пока очередная из точек не совпадет с концом отрезка. После этого шаг уменьшается (обычно в 4 раза) и перебор точек с новым шагом осуществляется в противоположном направлении до тех пор, пока значения \(f(x)\) снова не перестанут уменьшаться или не будет достигнут противоположный край отрезка и т.д. Описанный процесс завершается, когда перебор в каком-либо направлении закончен, а длина шага \(\left|h_{r}\right| \leq \epsilon_{x}\).

\textbf{Алгоритм метода:}
\begin{enumerate}
\item Выполняем присваивание \(r = 1, i = 0, x^{r}_{i} = a, h_{r} = \frac{b-a}{4}\).
\item Делаем очередной шаг \(x^{r}_{i+1} = x^{r}_{i} + h_{r}\); проверяем, что \(x^{r}_{i+1} \in \left[a, b\right]\): если принадлежит, то переходим к шагу 3, в противном случае - к шагу 4.
\item Вычисляем и сравниваем \(f(x^{r}_{i})\) и \(f(x^{r}_{i+1})\). Если \(f(x^{r}_{i}) \geq f(x^{r}_{i+1})\), то положить \(i = i + 1\) и перейти к шагу 2, в противном случае - к шагу 4.
\item Полагаем \(x^{*} = x^{r}_{i}\) и проверяем условие окончания поиска: если \(\left|h_{r}\right| \leq \epsilon_{x}\), то завершаем вычисления; в противном случае переходим к шагу 5.
\item Переходим к следующей итерации: изменяем направление поиска и уменьшаем шаг. Для этого выполняем присваивание \(r = r + 1, i = 0, x^{r}_{i} = x^{*}, h_{r} = \frac{h_{r-1}}{4}\) и переходим к шагу 2.
\end{enumerate}

\subsection{Последовательные методы поиска}
\label{sec:PosledSearch}
Последовательные методы поиска на практике используются чаще, чем пассивные. Это обусловлено тем, что использование информации о результатах предыдущих измерений для выбора очередной экспериментальной точки \(x_{i}\) как правило приводит к более эффективному поиску.

\subsubsection{Метод дихотомии}
В методе дихотомии испытания проводятся парами. Точки каждой последующей пары разнесены между собой на величину \(\delta_{x} < \epsilon_{x}\). Испытания производятся в середине ТИН. По значениям \(f(x)\), полученным в этих точках, одна половина ТИН в силу унимодальности целевой функции исключается из дальнейшего рассмотрения.

\textbf{Алгоритм метода:}
\begin{enumerate}
\item Выполняем присваивание \(r = 1, a^{1} = a, b^{1} = b, \text{ТИН}_{1} = \left[a^{1}, b^{1}\right]\).
\item Вычисляем величины \(x^{r}_{0} = \frac{b^{r}-a^{r}}{2}\), \(x^{r}_{1} = x^{r}_{0} - \frac{\delta_{x}}{2}\), \(x^{r}_{2} = x^{r}_{0} + \frac{\delta_{x}}{2}\).
\item Вычисляем значения \(f(x^{r}_{1})\) и \(f(x^{r}_{2})\).
\item Если \(f(x^{r}_{1}) < f(x^{r}_{2})\), то выполняем присваивание \(a^{r+1} = a^{r}\), \(b^{r+1} = x^{r}_{0}\); в противном случае \(a^{r+1} = x^{r}_{0}\), \(b^{r+1} = b^{r}\). В обоих случаях \(\text{ТИН}_{r+1} = \left[a^{r+1}, b^{r+1}\right]\).
\item Если \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), то заканчиваем вычисления; иначе выполняем присваивание \(r = r + 1\) и переходим к шагу 2.
\end{enumerate}
В качестве приближенного значения точки минимума \(x^{*}\) может быть принята любая точка последнего ТИН.

На рисунке \ref{fig:DihotomSearch} показан один шаг метода дихотомии.

Поскольку после каждой итерации длина ТИН уменьшается в 2 раза, можно априорно оценить количество итераций по заданной точности решения. Действительно, после первой итерации \(\left|\text{ТИН}_{2}\right| = \frac{b-a}{2}\), после второй итерации \(\left|\text{ТИН}_{3}\right| = ((\frac{b-a}{2})/2) = \frac{b-a}{2^{2}}\) и т.д. Тогда после \(r\)-ой итерации имеем \(\left|\text{ТИН}_{r+1}\right| = \frac{b-a}{2^{r}}\). Но, так как условие окончания поиска \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), получаем \(\frac{b-a}{2^{r}} \leq \epsilon_{x}\). Заменив знак неравенства на равенство и выразив \(r\), получим оценку количества итераций.

\textit{Замечание 1}. Если производная целевой функции считается достаточно просто, можно видоизменить метод дихотомии. На концах рассматриваемого отрезка вычисляют производные целевой функции, отрезок делят пополам и вычисляют производную в средней точке. Для следующей итерации выбирают тот отрезок из двух получившихся, на концах которого знаки производной различны (по определению унимодальной функции ее производная меняет знак на отрезке поиска только один раз).

\textit{Замечание 2}. В методе дихотомии на каждой итерации значение функции вычисляется дважды. Однако, как было указано в разделе \ref{sec:ClassMetOpt}, в общем случае стараются уменьшить количество таких вычислений. Поэтому более эффективными являются методы, где новые <<экспериментальные>> точки на каждой (по возможности) итерации выбираются таким образом, чтобы значение функции приходилось вычислять только один раз.

\subsubsection{Метод Фибоначчи}
Идея метода Фибоначчи состоит в том, чтобы определять новые <<экспериментальные>> точки с помощью чисел Фибоначчи, поэтому сначала следует ввести определение и рассмотреть свойства этих чисел. Числа Фибоначчи задаются рекуррентным соотношением \(F_{i} = F_{i-1} + F_{i-2}\), \(i \geq 2\), \(F_{0} = F_{1} = 1\). Вычислять числа Фибоначчи нерекуррентным образом можно с помощью выражения
\begin{equation}
\label{eq:num6}
F_{i} = \frac{\left(\frac{1}{\tau}\right)^{i+1}-\left(-\tau\right)^{i+1}}{\sqrt{5}},
\end{equation}
где \(\tau = \frac{\sqrt{5} - 1}{2} \approx 0,618\) - решение квадратного уравнения
\begin{equation}
\label{eq:num7}
\tau^{2} + \tau - 1 = 0
\end{equation}
При больших значениях \(i\) членом \(\left(-\tau\right)^{i+1}\) можно пренебречь. Тогда
\begin{equation}
\label{eq:num8}
F_{i} \approx \frac{\left(\frac{1}{\tau}\right)^{i+1}}{\sqrt{5}}
\end{equation}
Можно заметить, что из \eqref{eq:num8} следует \(F_{i-1} \approx \frac{\left(\frac{1}{\tau}\right)^{i}}{\sqrt{5}}\) и, следовательно,
\begin{equation}
\label{eq:num9}
\frac{F_{i-1}}{F_{i}} \approx \tau,
\end{equation}
то есть при больших \(i\) отношение двух соседних чисел Фибоначчи примерно постоянно.

\textbf{Алгоритм метода} состоит из двух этапов.

Первый этап состоит из \(\left(N-1\right)\)-ой итерации для \(r = 1, 2, \ldots, N-1\). Рассмотрим схему r-ой итерации, когда \(\text{ТИН}_{r} = \left[a^{r}, b^{r}\right]\):
\begin{enumerate}
\item Вычисляем величины \(x^{r}_{1} = a^{r} + \left|\text{ТИН}_{r}\right|\frac{F_{N-r-1}}{F_{N-r+1}}\), \(x^{r}_{2} = a^{r} + \left|\text{ТИН}_{r}\right|\frac{F_{N-r}}{F_{N-r+1}}\).
\item Вычисляем значения \(f(x^{r}_{1})\) и \(f(x^{r}_{2})\).
\item Если \(f(x^{r}_{1}) < f(x^{r}_{2})\), то выполняем присваивание \(a^{r+1} = a^{r}\), \(b^{r+1} = x^{r}_{2}\); в противном случае \(a^{r+1} = x^{r}_{1}\), \(b^{r+1} = b^{r}\). В обоих случаях \(\text{ТИН}_{r+1} = \left[a^{r+1}, b^{r+1}\right]\).
\end{enumerate}

Данный этап алгоритма обладает тем свойством, что после выполнения \(\left(N-1\right)\)-ой итерации имеет место следующая ситуация: \(x^{N-1}_{1} = x^{N-1}_{2} = x^{N-1}\). Таким образом, на \(\left(N-1\right)\)-ой итерации сужения ТИН не происходит: \(\text{ТИН}_{N-1} = \left[a^{N-1}, b^{N-1}\right] = \text{ТИН}_{N-2} = \left[a^{N-2}, b^{N-2}\right]\), причем точка \(x^{N-1}\) оказывается в середине \(\text{ТИН}_{N-1}\).

Второй этап позволяет определить, с какой стороны от точки \(x^{N-1}\) лежит точка минимума. Для этого:
\begin{enumerate}
\item Находим точку \(x^{N} = x^{N-1} + \delta_{x}\), где \(\delta_{x} \ll \left|\text{ТИН}_{N-1}\right|\) - свободный параметр алгоритма.
\item Вычисляем значение \(f(x^{N})\).
\item Если \(f(x^{N}) > f(x^{N-1})\), то выполняем присваивание \(\text{ТИН}_{N} = \left[a^{N-1}, x^{N-1}\right]\); в противном случае \(\text{ТИН}_{N} = \left[x^{N-1}, b^{N-1}\right]\).
\end{enumerate}
В качестве приближенного значения точки минимума \(x^{*}\) может быть принята любая точка последнего ТИН.

Некоторые \textbf{свойства метода Фибоначчи}.

\textit{Утверждение 1}. Для любого \(r = 1, 2, \ldots, N-2\) метод Фибоначчи обладает следующим свойством: одна из точек \(x^{r+1}_{1}\), \(x^{r+1}_{2}\) совпадает с одной из точек \(x^{r}_{1}\), \(x^{r}_{2}\).

\(\blacktriangleleft\) Пусть на \(r\)-ой итерации выполняется \(f(x^{r}_{1}) < f(x^{r}_{2})\), тогда \(\text{ТИН}_{r+1} = \left[a^{r}, x^{r}_{2}\right]\) и \(x^{r}_{1} \in \text{ТИН}_{r+1}\). Рассмотрим точку \(x^{r+1}_{2} = a^{r} + \left|\text{ТИН}_{r+1}\right|\frac{F_{N-(r+1)}}{F_{N-(r+1)+1}} = a^{r} + \left(x^{r}_{2} - a^{r}\right)\frac{F_{N-r-1}}{F_{N-r}}\). Так как \(x^{r}_{2} = a^{r} + \left|\text{ТИН}_{r}\right|\frac{F_{N-r}}{F_{N-r+1}}\), то \(x^{r+1}_{2} = a^{r} + \left(a^{r} + \left|\text{ТИН}_{r}\right|\frac{F_{N-r}}{F_{N-r+1}} - a^{r}\right)\frac{F_{N-r-1}}{F_{N-r}} = a^{r} + \left|\text{ТИН}_{r}\right|\frac{F_{N-r-1}}{F_{N-r+1}} = x^{r}_{1}\) \(\blacktriangleright\)

Доказательство для случая \(f(x^{r}_{1}) > f(x^{r}_{2})\) проводится аналогично. Указанное свойство позволяет на каждой итерации (кроме первой) производить испытания только в одной точке.

\textit{Утверждение 2}.

Метод Фибоначчи является достаточно эффективным (см. раздел \ref{sec:EffectOneVarMethods}) методом одномерной оптимизации, однако в нем доставляет неудобство тот факт, что после выбора значения параметра \(N\) следует обязательно сделать \(N-1\) итераций, без возможности остановки даже в том случае, когда длина очередного ТИН стала меньше заданной точности решения. От этого недостатка можно избавиться следующим образом: из \eqref{eq:num9} следует, что отношение соседних чисел Фибоначчи примерно постоянно, следовательно, на каждой итерации можно выбирать экспериментальные точки так, чтобы они делили ТИН в одном и том же отношении \(\tau\), которое не зависит от \(N\). Эти рассуждения ложатся в основу метода золотого сечения.

\subsubsection{Метод золотого сечения}
Метод золотого сечения является почти таким же эффективным, как метод Фибоначчи, но позволяет остановить вычисления на любой итерации. Определение золотого сечения дается следующим образом: говорят, что точка \(c\) выполняет золотое сечение отрезка \(\left[a, b\right]\), если \(\frac{c-a}{b-a} = \tau\).

Из определения золотого сечения следует, что \(\frac{b-c}{b-a} = \frac{\left(b-a\right)-\left(c-a\right)}{b-a} = 1 -\frac{c-a}{b-a} = 1 - \tau\).

\textbf{Алгоритм метода}:
\begin{enumerate}
\item Выполняем присваивание \(r = 1, a^{1} = a, b^{1} = b, \text{ТИН}_{1} = \left[a^{1}, b^{1}\right]\).
\item Вычисляем величины \(x^{r}_{1} = b^{r} - \left(b^{r}-a^{r}\right)\tau\), \(x^{r}_{2} = a^{r} + \left(b^{r}-a^{r}\right)\tau\).
\item Вычисляем значения \(f(x^{r}_{1})\) и \(f(x^{r}_{2})\).
\item Если \(f(x^{r}_{1}) < f(x^{r}_{2})\), то выполняем присваивание \(a^{r+1} = a^{r}\), \(b^{r+1} = x^{r}_{2}\); в противном случае \(a^{r+1} = x^{r}_{1}\), \(b^{r+1} = b^{r}\). В обоих случаях \(\text{ТИН}_{r+1} = \left[a^{r+1}, b^{r+1}\right]\).
\item Если \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), то заканчиваем вычисления; иначе выполняем присваивание \(r = r + 1\) и переходим к шагу 2.
\end{enumerate}
В качестве приближенного значения точки минимума \(x^{*}\) может быть принята любая точка последнего ТИН.

Некоторые \textbf{свойства метода золотого сечения}.

\textit{Утверждение 1}. Для любого \(r \geq 1\) метод золотого сечения обладает следующим свойством: одна из точек \(x^{r+1}_{1}\), \(x^{r+1}_{2}\) совпадает с одной из точек \(x^{r}_{1}\), \(x^{r}_{2}\).

\(\blacktriangleleft\) Пусть на \(r\)-ой итерации выполняется \(f(x^{r}_{1}) < f(x^{r}_{2})\), тогда \(\text{ТИН}_{r+1} = \left[a^{r}, x^{r}_{2}\right]\) и \(x^{r}_{1} \in \text{ТИН}_{r+1}\). Чтобы доказать справедливость утверждения, нужно показать, что верно соотношение \(\frac{x^{r}_{1}-a^{r}}{x^{r}_{2}-a^{r}} = \tau\). Из 2-го шага алгоритма следует, что \(b^{r}-x^{r}_{1} = \left(b^{r}-a^{r}\right)\tau \Rightarrow b^{r}-x^{r}_{1}-a^{r}+a^{r} = \left(b^{r}-a^{r}\right)\tau \Rightarrow \left(b^{r}-a^{r}\right)-\left(x^{r}_{1}-a^{r}\right) = \left(b^{r}-a^{r}\right)\tau \Rightarrow x^{r}_{1} - a^{r} = \left(b^{r}-a^{r}\right)\left(1-\tau\right)\). Аналогично имеем \(x^{r}_{2}-a^{r} = \left(b^{r}-a^{r}\right)\tau\). Разделив первый из полученных результатов на второй, получаем \(\frac{x^{r}_{1}-a^{r}}{x^{r}_{2}-a^{r}} = \frac{1-\tau}{\tau}\). Но из \eqref{eq:num7} следует, что \(1-\tau = \tau^{2}\), в результате чего имеем \(\frac{x^{r}_{1}-a^{r}}{x^{r}_{2}-a^{r}} = \frac{1-\tau}{\tau} = \frac{\tau^{2}}{\tau} = \tau \blacktriangleright\)

Доказательство для случая \(f(x^{r}_{1}) > f(x^{r}_{2})\) проводится аналогично. Указанное свойство позволяет на каждой итерации (кроме первой) производить испытания только в одной точке.

\textit{Утверждение 2}. Точки \(x^{r}_{1}\), \(x^{r}_{2}\) расположены симметрично относительно концов ТИН.

\(\blacktriangleleft\) Из 2-го шага алгоритма следует, что точка \(x^{r}_{1}\) отстоит от точки \(b^{r}\) на величину \(\left(b^{r}-a^{r}\right)\tau\); точка \(x^{r}_{2}\) отстоит от точки \(a^{r}\) на ту же величину. \(\blacktriangleright\)

\textit{Утверждение 3}. Поскольку после каждой итерации длина ТИН уменьшается в \(\tau\) раз, можно априорно оценить количество итераций по заданной точности решения. Действительно, после первой итерации \(\left|\text{ТИН}_{2}\right| = \left(b-a\right)\tau\), после второй итерации \(\left|\text{ТИН}_{3}\right| = \left(b-a\right)\tau\tau = \left(b-a\right)\tau^{2}\) и т.д. Тогда после \(r\)-ой итерации имеем \(\left|\text{ТИН}_{r+1}\right| = \left(b-a\right)\tau^{r}\). Но, так как условие окончания поиска \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), получаем \(\left(b-a\right)\tau^{r} \leq \epsilon_{x}\). Заменив знак неравенства на равенство и выразив \(r\), получим оценку количества итераций.

\subsection{Сравнение эффективности методов одномерной безусловной оптимизации}
\label{sec:EffectOneVarMethods}

\clearpage

\chapter{Линейное программирование}

\clearpage

\chapter{Комбинаторная оптимизация}

\clearpage

\chapter{Стохастическая оптимизация}

\clearpage

\addcontentsline{toc}{chapter}{Литература} % список литературы автоматически в оглавление не попадает
\bibliography{biblio/doc}

\end{document}