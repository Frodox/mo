% создаем документ типа "отчет"
\documentclass[a4paper,12pt]{report}
% фишки для набора формул
\usepackage{amsmath,amssymb}
% размер формул
%\DeclareMathSizes{12}{12}{10}{8}
% для вывода русских символов задаем шрифты и кодировки
\usepackage[OT2,T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{pscyr}
% рулим полями страницы
\usepackage[top=2cm, bottom=2cm, left=2cm, right=1.5cm]{geometry}
% включаем возможность создания длинных таблиц, которые находятся на нескольких листах
\usepackage{longtable}
% рулим header-ами и footer-ами
\usepackage{fancyhdr}
% включаем возможность copy-paste из PDF
\usepackage{cmap}
% для абзацных отступов (красная строка)
\usepackage{indentfirst}
% в России после номера таблицы ставится точка, а не двоеточие, поэтому нужен этот пакет
\usepackage[font=footnotesize,labelsep=period,skip=0pt,singlelinecheck=false,center]{caption}
% нужно для ввода в таблицы инструкции m{..} - позволяет центрировать по вертикали содержимое ячеек
\usepackage{array}
% нужно для аналогов rowspan в HTML
\usepackage{multirow}
% косая черта в ячейке таблицы
\usepackage{slashbox}
% ссылки в тексте документа
\usepackage[colorlinks,filecolor=black,citecolor=black,linkcolor=black,unicode]{hyperref}
% вставка рисунков
\usepackage{graphicx}
% относительный путь до каталога с рисунками
\graphicspath{{img/}}

\bibliographystyle{unsrt} % стиль библиографических ссылок БибТеХа

\newcommand{\docTitle}{Методы оптимизации}
\newcommand{\docVersion}{0.1}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % своя команда для рисования линий на титульной странице

\renewcommand{\theenumi}{\arabic{enumi}} % меняем везде перечисления на цифра.цифра
\renewcommand{\baselinestretch}{1.25} % делаем полуторный интервал

% переопределяем стиль страницы с собственными header-ами и footer-ами
\fancypagestyle{plain}
{
  \lhead{\textbf{\docTitle} (текст лекций)} % слева в header-е название документа
  \chead{}
  \rhead{\emph{Версия:} \docVersion} % справа в header-е номер версии
  \lfoot{}
  \cfoot{}
  \rfoot{\thepage} % справа в footer-е номер страницы
  \renewcommand{\headrulewidth}{0.4pt} % отчеркивание для header-а
  \renewcommand{\footrulewidth}{0.4pt} % отчеркивание для footer-а
}

\begin{document}

\begin{titlepage}

\begin{center}

% Разработчик
\textsc{\LARGE Прудников А.М.}\\[7.0cm]

% Общий заголовок
\textsc{\Large Текст лекций по курсу}\\[0.5cm]

% Заголовок конкретного документа
\HRule \\[0.4cm]
{ \huge \bfseries \docTitle}\\[0.4cm]

\HRule \\[1.5cm]

% Редакция
\begin{minipage}{0.8\textwidth}
\begin{flushright} \large
\emph{Версия:} \docVersion
\end{flushright}
\end{minipage}

\vfill

% Дата
{\large Москва, 2012}

\end{center}

\end{titlepage}

\setcounter{page}{2}

\pagestyle{plain}

\clearpage

\tableofcontents

\clearpage

\chapter{Понятие математической оптимизации}

\section{Исследование операций и место методов оптимизации в данной дисциплине}

\textbf{Исследование операций} – математическая дисциплина, занимающаяся построением, разработкой и применением математических моделей принятия оптимальных решений во всех областях человеческой деятельности.

\textbf{Операция} – это всякое мероприятие (система действий), объединенное единым замыслом и направленное к достижению какой-то цели.

Пусть необходимо выполнить какое-либо мероприятие для достижения определенной цели (\textbf{операцию}). Обычно существует свобода выбора в том, как это мероприятие организовать 
(например, выбор техники, распределение ресурсов и т.д.). \textbf{<<Решение>>} – это какой-то выбор из ряда допустимых возможностей.

Краеугольным камнем исследования операций является \textbf{математическое моделирование}. Данные, полученные при исследовании математических моделей, являются основой для принятия решений. 
Но общих способов построения математических моделей и методов их решения не существует. В каждом конкретном случае модель выбирается исходя из вида операции, ее целевой направленности, 
с учетом задачи исследования.

Наиболее известными методами исследования операций (являющимися, зачастую, самостоятельными математическими дисциплинами), являются:
\begin{itemize}
\item Математическое программирование – теория и методы решения задач о нахождении экстремумов функций на множествах векторного пространства, определяемых линейными и нелинейными ограничениями 
(равенствами и неравенствами). (Присутствие в названии термина <<программирование>> объясняется тем, что первые исследования оптимизационных задач были в сфере экономики, а в английском языке 
слово <<programming>> означает планирование, составление планов или программ).
\item Сетевые модели – решение оптимизационных задач с использованием графов.
\item Марковские процессы – метод решения стохастических задач, где процесс принятия решений можно представить конечным числом состояний.
\item Теория игр – методы изучения оптимальных стратегий в играх. Теория игр помогает выбрать лучшие стратегии с учётом представлений о других участниках, их ресурсах и их возможных поступках.
\item Теория массового обслуживания (теория очередей) – раздел теории вероятностей, целью исследований которого является рациональный выбор структуры системы обслуживания и процесса обслуживания на 
основе изучения потоков требований на обслуживание, длительности ожидания и длины очередей.
\item Имитационное моделирование – метод исследования, при котором изучаемая система заменяется компьютерной моделью, с достаточной точностью описывающей реальную систему, и с ней проводятся эксперименты 
с целью получения информации об этой системе. Экспериментирование с моделью называют имитацией.
\end{itemize}

В данном курсе будет изучаться математическое программирование, методы которого и являются так называемыми \textbf{методами оптимизации}.

\section{Понятие оптимизации}
Оптимизация в самом широком смысле - это выбор наилучшего варианта из множества возможных. Рассмотрим некоторые классические примеры оптимизационных задач.

\subsection{Задача коммивояжера}
Дано некоторое количество городов и расстояния между ними. Коммивояжер должен посетить каждый город и вернуться к месту отправления. Какой маршрут он должен выбрать? Зададим расстояния между городами (допустим, их пять) в виде следующей таблицы:

\begin{center}
\begin{tabular}{|l|>{$}c<{$}|>{$}c<{$}|>{$}c<{$}|>{$}c<{$}|>{$}c<{$}|>{$}c<{$}|}
\hline
\backslashbox{}{} & 1 & 2 & 3 & 4 & 5\\
\hline
1 & - & 1 & 7 & 2 & 8\\
\hline
2 & 2 & - & 10 & 3 & 1\\
\hline
3 & 7 & 10 & - & 2 & 6\\
\hline
4 & 2 & 3 & 2 & - & 4\\
\hline
5 & 8 & 1 & 6 & 4 & -\\
\hline
\end{tabular}
\end{center}

Проложим несколько маршрутов и посчитаем расстояние для них:
\begin{itemize}
\item Маршрут \(5 \rightarrow 1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5\), расстояние \(8+1+10+2+4=25\)
\item Маршрут \(5 \rightarrow 2 \rightarrow 1 \rightarrow 4 \rightarrow 3 \rightarrow 5\), расстояние \(1+1+2+2+6=12\)
\end{itemize}

Каким же образом (исключая полный перебор) следует выбрать кратчайший маршрут?

\subsection{Задача размещения производства}
\label{sec:ZRP}
Пусть в некотором регионе имеется ряд потребителей некоторой продукции. Нужно определить, как разместить в этом регионе заводы по производству данной продукции.

Существует два крайних решения:
\begin{enumerate}
\item Можно разместить только один завод; в этом случае производственные затраты будут минимальны, но станут максимальными затраты на доставку продукции потребителям (транспортные затраты).
\item Можно разместить большое количество заводов (рядом с каждым потребителем); в этом случае транспортные затраты будут минимальны, но станут максимальными производственные затраты.
\end{enumerate}

Очевидно, что оптимальное решение заключается в минимизации суммарных затрат \(C_{\text{общ}} = C_{\text{произв}} + C_{\text{трансп}} \rightarrow \min\).

\subsection{Построение математической модели}
Как было сказано выше, для решения любых задач исследования операций (и, соответственно, задач математического программирования) необходимо формализовать решаемую задачу, построив ее математическую модель. В самых общих чертах процесс построения математической модели можно представить следующим образом:
\begin{enumerate} 
\item Определение неизвестных параметров (элементов решения).
\item Выражение условий задачи через введенные на первом шаге неизвестные.
\item Выбор критерия оптимальности.
\end{enumerate}

Попробуем выполнить описанные выше шаги для построения математической модели задачи размещения производства (см. раздел \ref{sec:ZRP}). 

На шаге \textbf{определения неизвестных параметров} введем переменные \(x_{ij}\) - объем перевозимой продукции с \(i\)-го завода \(j\)-му потребителю; здесь \(i=\overline{1,m}\) - количество заводов, \(j=\overline{1,n}\) - количество потребителей. 

Теперь \textbf{выразим условия задачи} через эти переменные:
\begin{enumerate}
\item Очевидно, что количество перевозимой продукции не может быть отрицательно: \(x_{ij}\geq 0\).
\item Если обозначить известный нам объем заказов (потребления) продукции \(j\)-м потребителем через \(b_{j}\), то на объем перевозок можно наложить ограничение \(\sum\limits_{i=1}^m x_{ij} = b_{j}\) (не следует везти к потребителю продукции больше, чем он заказывает).
\item Если обозначить известные нам удельные транспортные затраты на перевозку изделий от \(i\)-го завода \(j\)-му потребителю через \(c_{ij}\), то можно составить уравнение для транспортных затрат: \(C_{\text{трансп}} = \sum\limits_{i=1}^m \sum\limits_{j=1}^n c_{ij}x_{ij}\).
\item Если обозначить известную нам стоимость производства на \(i\)-ом заводе (которая, вообще говоря, зависит от объемов производства) через \(f_{i}(x_{i})\), то можно составить уравнение для производственных затрат: \(C_{\text{произв}} = \sum\limits_{i=1}^m f_{i}(\sum\limits_{j=1}^n x_{ij})\).
\end{enumerate}
Осталось \textbf{выбрать критерий оптимальности}, однако это мы уже сделали в п. \ref{sec:ZRP}: суммарные затраты должны быть минимальны.

Таким образом, в результате формализации задачи мы построили ее математическую оптимизационную модель следующего вида:

\begin{equation}
\label{eq:num1}
\min \left\{\sum\limits_{i=1}^m f_{i}(\sum\limits_{j=1}^n x_{ij}) + \sum\limits_{i=1}^m \sum\limits_{j=1}^n c_{ij}x_{ij}\right\}
\end{equation}
при ограничениях
\begin{align}
\label{eq:num2}
\begin{cases}
\sum\limits_{i=1}^m x_{ij} = b_{j} \\
x_{ij} \geq 0
\end{cases}	
i=\overline{1,m}, j=\overline{1,n}
\end{align}

Опираясь на полученный результат, можно попробовать записать постановку оптимизационной задачи в общем виде.

\section{Общий вид однокритериальной оптимизационной задачи}

В общем виде задача математического программирования ставится следующим образом: найти максимум (минимум) функции 
\begin{equation}
\label{eq:num3}
f(x_{1}, x_{2}, \ldots, x_{n}) = f(\bar{x})	
\end{equation}
при ограничениях
\begin{align}
\label{eq:num4}
\begin{cases}
g_{i}(x_{1}, x_{2}, \ldots, x_{n}) \leq b_{i}, i=\overline{1,m} \\
x_{j} \geq 0, j=\overline{1,n}
\end{cases}	
\end{align}

Здесь:
\begin{itemize}
\item \(f(\bar{x})\) - целевая функция;
\item система неравенств и условия неотрицательности переменных \eqref{eq:num4} - система ограничений.
\end{itemize}

Всякое решение задачи с учетом системы ограничений называется \textbf{допустимым решением}. Допустимое решение, максимизирующее (минимизирующее) целевую функцию, называется \textbf{оптимальным решением}. Таким образом, задача математического программирования заключается в нахождении оптимального решения, которое по определению обеспечивает максимальное (минимальное) значение целевой функции с учетом заданных ограничений.

\section{Особенности задачи математического программирования}
\begin{enumerate}
\item Если требуется найти минимум \(f(\bar{x})\), то это эквивалентно поиску максимума \(-f(\bar{x})\).
\item В любом случае можно добиться условия неотрицательности переменных, то есть, если задано ограничение \(x_{j} \geq x_{j\_min}\), то можно сделать замену переменных \(x^{'}_{j} = x_{j} - x_{j\_min} \geq 0\).
\item Если заданы ограничения вида \(g_{i}(\bar{x}) \geq b_{i}\), то простой заменой знака приходим к первоначальной форме \(-g_{i}(\bar{x}) \leq -b_{i}\).
\item Функция \(f(\bar{x})\) может иметь несколько экстремумов, а именно локальные экстремумы и глобальный экстремум. Функция \(f(\bar{x})\), определенная на области \(D\), достигает на ней глобального максимума \(\bar{x}^{*} \in D\), если неравенство \(f(\bar{x}) \leq f(\bar{x}^{*})\) справедливо для любой точки \(\bar{x} \in D\). Функция \(f(\bar{x})\), определенная на области \(D\), достигает на ней локального максимума \(\bar{x}^{*} \in D\), если неравенство \(f(\bar{x}) \leq f(\bar{x}^{*})\) справедливо для точек из некоторой окрестности \(\bar{x}^{*}\).
\item В математическом анализе для нахождения экстремумов функций используются производные (это классические методы оптимизации). Такие методы применяют лишь для сравнительно простых задач из-за следующих недостатков:
\begin{itemize}
\item для использования таких методов нужно, чтобы функции \(f(\bar{x})\) и \(g_{i}(\bar{x})\) были непрерывны и имели частные производные по крайней мере до 2-го порядка;
\item с помощью классических методов можно найти экстремум только внутри области; если оптимальная точка находится на границе области, то эти методы бессильны;
\item на переменные \(x_{j}\) не должны быть наложены условия целочисленности.
\end{itemize}
\end{enumerate}

\section{Классификация задач математического программирования}
В зависимости от вида функций, входящих в критерий оптимальности и систему ограничений, а также допустимой области изменения переменных, задачи математического программирования разделяются на следующие классы:
\begin{enumerate}
\item Линейное программирование - целевая функция и ограничения являются линейными. Область допустимых значений - многогранник, а оптимальное решение находится в одной из его вершин.
\item Нелинейное программирование - или целевая функция, или какое-либо ограничение содержит нелинейную зависимость.
\item Дискретное программирование - переменные могут принимать только целочисленные значения.
\end{enumerate}

\section{Классификация методов решения задач оптимизации}
\label{sec:ClassMetOpt}
Особенность задач оптимизации состоит в том, что вычисление значений целевой функции и значений ограничивающих функций может требовать больших затрат времени. В связи с этим возникает проблема решения задач оптимизации при наименьшем числе испытаний.
\textbf{Испытанием} называется операция однократного вычисления функций \(f(\bar{x})\) и \(g_{i}(\bar{x})\) (и, в некоторых случаях, их производных) в некоторой точке \(\bar{x}\).
Далее будем говорить, что задача оптимизации решается с помощью \textbf{поискового метода оптимизации}, если используется следующая процедура поиска оптимального решения \(\bar{x}^{*}\):
\begin{itemize}
\item по очереди при \(r=0,1,2,\ldots,N-1\) производятся испытания в точках
\begin{equation}
\label{eq:num5}
\bar{x}^{r+1} = \Psi_{r+1}\left(\bar{x}^{0}, f(\bar{x}^{0}), g_{i}(\bar{x}^{0}),\ldots,\bar{x}^{r}, f(\bar{x}^{r}), g_{i}(\bar{x}^{r})\right)
\end{equation}
\item в качестве решения задачи берется точка \(\bar{x}^{*}\), которая находится из условия \(f(\bar{x}^{*})=\underset{r\in[0;N]}{\min}f(\bar{x}^{r})\).
\end{itemize}
Здесь:
\begin{itemize}
\item \(r\) - текущий номер испытания;
\item \(N\) - число испытаний;
\item \(\bar{x}^{0}\) - начальное приближение;
\item \(\Psi_{r}\) - алгоритм поисковой оптимизации на \(r\)-ом шаге.
\end{itemize}

В общем случае \textbf{алгоритмом поисковой оптимизации} называется способ выбора начального приближения \(\bar{x}^{0}\) и конкретная совокупность функций \(\left\{\Psi_{r}\right\}\). Таким образом, понятие алгоритма является более частным по сравнению с понятием метода (одному и тому же методу могут соответствовать разные алгоритмы).

Теперь проведем классификацию методов решения с учетом введенным понятий.

\begin{enumerate}
\item \textbf{Классификация по наличию или отсутствию системы ограничений}. Если в задаче отсутствует система ограничений, то она решается методами \textbf{безусловной} оптимизации; в противном случае - методами \textbf{условной} оптимизации.
\item \textbf{Классификация по размерности вектора \(\bar{x}\)}. Если \(\bar{x}\) на самом деле скаляр, то применяются \textbf{одномерные} методы оптимизации; в противном случае - \textbf{многомерные}.
\item \textbf{Классификация по характеру искомого решения}. Если метод поиска гарантирует отыскание только локального экстремума, то это метод \textbf{локальной} оптимизации. Если делается попытка отыскать глобальный экстремум, то это метод \textbf{глобальной} оптимизации. Следует отметить, что удовлетворительных с точки зрения вычислительной эффективности методов глобальной оптимизации не существует.
\item \textbf{Классификация по характеру функций \(\Psi_{r}\)}. Если функции \(\Psi_{r}\) являются детерминированными, то метод оптимизации называется \textbf{детерминированным}. Если же функции \(\Psi_{r}\) содержат случайные параметры, то метод оптимизации называется \textbf{стохастическим}.
\item \textbf{Классификация по способу выбора точек \(\bar{x}^{r}\)}. Если все точки \(\bar{x}^{r}\) назначаются заранее (до проведения испытаний), то метод оптимизации называется \textbf{пассивным}. Если же очередная точка \(\bar{x}^{r+1}\) определяется на основе всей или части информации об испытаниях в точках \(\bar{x}^{0},\ldots,\bar{x}^{r}\), то метод называется \textbf{последовательным}.
\item \textbf{Классификация по количеству предыдущих учитываемых шагов}. Если в последовательном методе при определении точки \(\bar{x}^{r+1}\) учитывается информация только о предыдущем испытании, то метод называется \textbf{одношаговым}. Если же используется информация о \(s > 1\) предыдущих испытаниях, то метод называется многошаговым (конкретнее, \(s\)-шаговым).
\item \textbf{Классификация по виду функций \(\Psi_{r}\)}. Если функция \(\Psi_{r}\) при всех \(N\) испытаниях одинакова, то метод называется \textbf{итерационным}. Если же функции \(\Psi_{r}\) меняются от испытания к испытанию, то метод является \textbf{неитерационным}.
\item \textbf{Классификация по порядку используемых производных}. Если при вычислении значений функций \(\Psi_{r}\) производные не используются, то метод называется \textbf{прямым} (или \textbf{нулевого порядка}). Если же используются производные \(k\)-го порядка, то метод называется методом \textbf{\(k\)-го порядка} (методы 1-го порядка также называются \textbf{градиентными}).
\end{enumerate}

\section{Условия окончания поиска}
Выбор условия (критерия) окончания поиска является еще одной важной проблемой при решении оптимизационных задач. Наиболее широко используемыми являются следующие критерии:
\begin{itemize}
\item \(\left\|\bar{x}^{r+1} - \bar{x}^{r}\right\| \leq \epsilon_{x}\), где \(\epsilon_{x}\) - требуемая точность решения по \(\bar{x}\), \(\left\|\cdot\right\|\) - некоторая векторная норма (например, евклидова);
\item \(\left|f(\bar{x}^{r+1}) - f(\bar{x}^{r})\right| \leq \epsilon_{f}\), где \(\epsilon_{f}\) - требуемая точность решения по \(f\).
\end{itemize}

\chapter{Нелинейное программирование}

\section{Безусловная оптимизация функций одной переменной}
Оптимизация функций одной переменной является, как правило, необходимым элементом методов оптимизации функций многих переменных. На первый взгляд кажется, что эта задача достаточно проста и решается с помощью дифференцирования (классический метод оптимизации). Однако для широкого класса функций это не так, поскольку задача решения уравнения \(f'(x) = 0\) может оказаться весьма сложной (или даже невозможной, если \(f(x)\) не дифференцируема).

Как уже было упомянуто выше, существование локальных экстремумов функции почти всегда затрудняет поиск глобального экстремума. Поэтому многие методы оптимизации применимы только тогда, когда любой локальный экстремум является одновременно и глобальным; это дает гарантию сходимости метода. Если же таких сведений о функции нет, то методы применять можно, но без гарантии сходимости.

Одним из классов функций, удовлетворяющих указанному условию, является класс \textbf{унимодальных (одноэкстремальных)} функций. Дадим определение такой функции для задачи поиска минимума (для задачи поиска максимума определение строится аналогичным образом).

Функция \(f(x)\) называется \textbf{унимодальной} на отрезке \(\left[a, b\right]\), если она непрерывна\footnote[1]{В общем случае это не так, но мы под унимодальной функцией будем подразумевать непрерывную унимодальную функцию.} на \(\left[a, b\right]\) и существуют такие \(\alpha\) и \(\beta\) (\(a \leq \alpha \leq \beta \leq b\)), что:
\begin{enumerate}
\item на отрезке \(\left[a, \alpha\right]\) при \(a < \alpha\) \(f(x)\) монотонно убывает;
\item на отрезке \(\left[\beta, b\right]\) при \(\beta < b\) \(f(x)\) монотонно возрастает;
\item существует минимум \(f(x)\) при \(x \in \left[\alpha, \beta\right]\).
\end{enumerate}
Примеры унимодальных функций приведены на рисунке \ref{fig:unimod_example}.

\newpage

\begin{figure}[ht]
\center{\includegraphics[width=0.8\linewidth]{unimod_example.png}}
\caption{Примеры унимодальных функций}
\label{fig:unimod_example}
\end{figure}

Прежде чем приступить к процедуре оптимизации, следует по возможности установить принадлежность целевой функции классу, для которого гарантирована сходимость процесса.

Заметим, что предположение об унимодальности функции в окрестности точки экстремума весьма естественно. Получение информации о таком промежутке является важным предварительным этапом процедуры оптимизации.

Рассмотрим с общих позиций ряд методов (разделы \ref{sec:PassiveSearch} и \ref{sec:PosledSearch}), позволяющих находить экстремумы (далее при рассмотрении алгоритмов будем говорить о задаче поиска минимума) унимодальных функций на отрезке \(\left[a, b\right]\). Эти методы объединяет идея сокращения \textbf{текущего интервала неопределенности (ТИН)}. Она состоит в том, что в процессе поиска исключаются из рассмотрения те подынтервалы, на которых точка оптимума \(x^{*}\) отсутствует в силу унимодальности целевой функции.

\subsection{Пассивные методы поиска}
\label{sec:PassiveSearch}
На практике подобные методы применяются, когда удобно провести независимые эксперименты по измерению значений функции \(f(x)\), а последовательное измерение этих значений трудоемко или невозможно по каким-либо причинам.

\subsubsection{Метод равномерного поиска}
Испытания проводятся в точках, которые определяются путем равномерного деления отрезка \(\left[a, b\right]\) на \(N\) одинаковых интервалов. Из вычисленных в узлах полученной сетки значений целевой функции выбирается наименьшее (пусть это значение достигается в некотором узле \(x_{k}\). Тогда, в связи с унимодальностью целевой функции, подынтервалы \(\left[a, x_{k-1}\right]\) и \(\left[x_{k+1}, b\right]\) можно исключить из рассмотрения, то есть сделать очередным ТИН отрезок \(\left[x_{k-1}, x_{k+1}\right]\).

\textbf{Алгоритм метода:}
\begin{enumerate}
\item Выполняем присваивание \(r = 1, a^{1} = a, b^{1} = b, \text{ТИН}_{1} = \left[a^{1}, b^{1}\right]\).
\item На очередном ТИН строим равномерную сетку с \(N + 1\) узлом.
\item Вычисляем значения целевой функции в узлах сетки.
\item Находим минимальное из вычисленных значений \(\min(f(x^{r}_{0}), f(x^{r}_{1}), \ldots, f(x^{r}_{N})) = f(x^{r}_{k})\).
\item Выполняем присваивание \(a^{r+1} = x^{r}_{k-1}, b^{r+1} = x^{r}_{k+1}, \text{ТИН}_{r+1} = \left[a^{r+1}, b^{r+1}\right]\).
\item Если \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), то заканчиваем вычисления; иначе выполняем присваивание \(r = r + 1\) и переходим к шагу 2.
\end{enumerate}
В качестве приближенного значения точки минимума \(x^{*}\) может быть принята любая точка последнего ТИН.

На рисунке \ref{fig:RavnomSearch} показан один шаг метода равномерного поиска при \(N = 13\).

Поскольку после каждой итерации длина ТИН уменьшается в фиксированное (\(\frac{N}{2}\)) количество раз, можно априорно оценить количество итераций по заданной точности решения. Действительно, после первой итерации \(\left|\text{ТИН}_{2}\right| = 2\frac{b-a}{N}\), после второй итерации \(\left|\text{ТИН}_{3}\right| = 2((2\frac{b-a}{N})/N) = (b-a)(\frac{2}{N})^{2}\) и т.д. Тогда после \(r\)-ой итерации имеем \(\left|\text{ТИН}_{r+1}\right| = (b-a)(\frac{2}{N})^{r}\). Но, так как условие окончания поиска \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), получаем \((b-a)(\frac{2}{N})^{r} \leq \epsilon_{x}\). Заменив знак неравенства на равенство и выразив \(r\), получим оценку количества итераций.

\subsubsection{Метод поразрядного поиска}
Можно усовершенствовать метод равномерного поиска, уменьшив количество вычислений значений целевой функции на каждой итерации. Во-первых, если \(f(x^{r}_{i}) < f(x^{r}_{i+1})\), то отпадает необходимость вычислять \(f(x)\) в точках \(x^{r}_{i+2}, x^{r}_{i+3}\) и т.д. Во-вторых, разумно было бы сначала грубо определить отрезок, содержащий оптимальную точку; а затем на этом отрезке искать ее с меньшим шагом дискретизации. Иными словами, следует сделать шаг сетки не постоянным, а зависящим от итерации.

В методе поразрядного поиска перебор точек происходит с некоторым шагом \(h_{r}\) до тех пор, пока не выполнится условие \(f(x^{r}_{i}) < f(x^{r}_{i+1})\), или пока очередная из точек не совпадет с концом отрезка. После этого шаг уменьшается (обычно в 4 раза) и перебор точек с новым шагом осуществляется в противоположном направлении до тех пор, пока значения \(f(x)\) снова не перестанут уменьшаться или не будет достигнут противоположный край отрезка и т.д. Описанный процесс завершается, когда перебор в каком-либо направлении закончен, а длина шага \(\left|h_{r}\right| \leq \epsilon_{x}\).

\textbf{Алгоритм метода:}
\begin{enumerate}
\item Выполняем присваивание \(r = 1, i = 0, x^{r}_{i} = a, h_{r} = \frac{b-a}{4}\).
\item Делаем очередной шаг \(x^{r}_{i+1} = x^{r}_{i} + h_{r}\); проверяем, что \(x^{r}_{i+1} \in \left[a, b\right]\): если принадлежит, то переходим к шагу 3, в противном случае - к шагу 4.
\item Вычисляем и сравниваем \(f(x^{r}_{i})\) и \(f(x^{r}_{i+1})\). Если \(f(x^{r}_{i}) \geq f(x^{r}_{i+1})\), то положить \(i = i + 1\) и перейти к шагу 2, в противном случае - к шагу 4.
\item Полагаем \(x^{*} = x^{r}_{i}\) и проверяем условие окончания поиска: если \(\left|h_{r}\right| \leq \epsilon_{x}\), то завершаем вычисления; в противном случае переходим к шагу 5.
\item Переходим к следующей итерации: изменяем направление поиска и уменьшаем шаг. Для этого выполняем присваивание \(r = r + 1, i = 0, x^{r}_{i} = x^{*}, h_{r} = \frac{h_{r-1}}{4}\) и переходим к шагу 2.
\end{enumerate}

\subsection{Последовательные методы поиска}
\label{sec:PosledSearch}
Последовательные методы поиска на практике используются чаще, чем пассивные. Это обусловлено тем, что использование информации о результатах предыдущих измерений для выбора очередной экспериментальной точки \(x_{i}\) как правило приводит к более эффективному поиску.

\subsubsection{Метод дихотомии}
В методе дихотомии испытания проводятся парами. Точки каждой последующей пары разнесены между собой на величину \(\delta_{x} < \epsilon_{x}\). Испытания производятся в середине ТИН. По значениям \(f(x)\), полученным в этих точках, одна половина ТИН в силу унимодальности целевой функции исключается из дальнейшего рассмотрения.

\textbf{Алгоритм метода:}
\begin{enumerate}
\item Выполняем присваивание \(r = 1, a^{1} = a, b^{1} = b, \text{ТИН}_{1} = \left[a^{1}, b^{1}\right]\).
\item Вычисляем величины \(x^{r}_{0} = \frac{b^{r}-a^{r}}{2}\), \(x^{r}_{1} = x^{r}_{0} - \frac{\delta_{x}}{2}\), \(x^{r}_{2} = x^{r}_{0} + \frac{\delta_{x}}{2}\).
\item Вычисляем значения \(f(x^{r}_{1})\) и \(f(x^{r}_{2})\).
\item Если \(f(x^{r}_{1}) < f(x^{r}_{2})\), то выполняем присваивание \(a^{r+1} = a^{r}\), \(b^{r+1} = x^{r}_{0}\); в противном случае \(a^{r+1} = x^{r}_{0}\), \(b^{r+1} = b^{r}\). В обоих случаях \(\text{ТИН}_{r+1} = \left[a^{r+1}, b^{r+1}\right]\).
\item Если \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), то заканчиваем вычисления; иначе выполняем присваивание \(r = r + 1\) и переходим к шагу 2.
\end{enumerate}
В качестве приближенного значения точки минимума \(x^{*}\) может быть принята любая точка последнего ТИН.

На рисунке \ref{fig:DihotomSearch} показан один шаг метода дихотомии.

Поскольку после каждой итерации длина ТИН уменьшается в 2 раза, можно априорно оценить количество итераций по заданной точности решения. Действительно, после первой итерации \(\left|\text{ТИН}_{2}\right| = \frac{b-a}{2}\), после второй итерации \(\left|\text{ТИН}_{3}\right| = ((\frac{b-a}{2})/2) = \frac{b-a}{2^{2}}\) и т.д. Тогда после \(r\)-ой итерации имеем \(\left|\text{ТИН}_{r+1}\right| = \frac{b-a}{2^{r}}\). Но, так как условие окончания поиска \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), получаем \(\frac{b-a}{2^{r}} \leq \epsilon_{x}\). Заменив знак неравенства на равенство и выразив \(r\), получим оценку количества итераций.

\textit{Замечание 1}. Если производная целевой функции считается достаточно просто, можно видоизменить метод дихотомии. На концах рассматриваемого отрезка вычисляют производные целевой функции, отрезок делят пополам и вычисляют производную в средней точке. Для следующей итерации выбирают тот отрезок из двух получившихся, на концах которого знаки производной различны (по определению унимодальной функции ее производная меняет знак на отрезке поиска только один раз).

\textit{Замечание 2}. В методе дихотомии на каждой итерации значение функции вычисляется дважды. Однако, как было указано в разделе \ref{sec:ClassMetOpt}, в общем случае стараются уменьшить количество таких вычислений. Поэтому более эффективными являются методы, где новые <<экспериментальные>> точки на каждой (по возможности) итерации выбираются таким образом, чтобы значение функции приходилось вычислять только один раз.

\subsubsection{Метод Фибоначчи}
Идея метода Фибоначчи состоит в том, чтобы определять новые <<экспериментальные>> точки с помощью чисел Фибоначчи, поэтому сначала следует ввести определение и рассмотреть свойства этих чисел. Числа Фибоначчи задаются рекуррентным соотношением \(F_{i} = F_{i-1} + F_{i-2}\), \(i \geq 2\), \(F_{0} = F_{1} = 1\). Вычислять числа Фибоначчи нерекуррентным образом можно с помощью выражения
\begin{equation}
\label{eq:num6}
F_{i} = \frac{\left(\frac{1}{\tau}\right)^{i+1}-\left(-\tau\right)^{i+1}}{\sqrt{5}},
\end{equation}
где \(\tau = \frac{\sqrt{5} - 1}{2} \approx 0,618\) - решение квадратного уравнения
\begin{equation}
\label{eq:num7}
\tau^{2} + \tau - 1 = 0
\end{equation}
При больших значениях \(i\) членом \(\left(-\tau\right)^{i+1}\) можно пренебречь. Тогда
\begin{equation}
\label{eq:num8}
F_{i} \approx \frac{\left(\frac{1}{\tau}\right)^{i+1}}{\sqrt{5}}
\end{equation}
Можно заметить, что из \eqref{eq:num8} следует \(F_{i-1} \approx \frac{\left(\frac{1}{\tau}\right)^{i}}{\sqrt{5}}\) и, следовательно,
\begin{equation}
\label{eq:num9}
\frac{F_{i-1}}{F_{i}} \approx \tau,
\end{equation}
то есть при больших \(i\) отношение двух соседних чисел Фибоначчи примерно постоянно.

\textbf{Алгоритм метода} состоит из двух этапов.

Первый этап состоит из \(\left(N-1\right)\)-ой итерации для \(r = 1, 2, \ldots, N-1\). Рассмотрим схему r-ой итерации, когда \(\text{ТИН}_{r} = \left[a^{r}, b^{r}\right]\):
\begin{enumerate}
\item Вычисляем величины \(x^{r}_{1} = a^{r} + \left|\text{ТИН}_{r}\right|\frac{F_{N-r-1}}{F_{N-r+1}}\), \(x^{r}_{2} = a^{r} + \left|\text{ТИН}_{r}\right|\frac{F_{N-r}}{F_{N-r+1}}\).
\item Вычисляем значения \(f(x^{r}_{1})\) и \(f(x^{r}_{2})\).
\item Если \(f(x^{r}_{1}) < f(x^{r}_{2})\), то выполняем присваивание \(a^{r+1} = a^{r}\), \(b^{r+1} = x^{r}_{2}\); в противном случае \(a^{r+1} = x^{r}_{1}\), \(b^{r+1} = b^{r}\). В обоих случаях \(\text{ТИН}_{r+1} = \left[a^{r+1}, b^{r+1}\right]\).
\end{enumerate}

Данный этап алгоритма обладает тем свойством, что после выполнения \(\left(N-1\right)\)-ой итерации имеет место следующая ситуация: \(x^{N-1}_{1} = x^{N-1}_{2} = x^{N-1}\). Таким образом, на \(\left(N-1\right)\)-ой итерации сужения ТИН не происходит: \(\text{ТИН}_{N} = \left[a^{N-1}, b^{N-1}\right] = \text{ТИН}_{N-1}\), причем точка \(x^{N-1}\) оказывается в середине \(\text{ТИН}_{N-1}\).

Второй этап позволяет определить, с какой стороны от точки \(x^{N-1}\) лежит точка минимума. Для этого:
\begin{enumerate}
\item Находим точку \(x^{N} = x^{N-1} + \delta_{x}\), где \(\delta_{x} \ll \left|\text{ТИН}_{N-1}\right|\) - свободный параметр алгоритма.
\item Вычисляем значение \(f(x^{N})\).
\item Если \(f(x^{N}) > f(x^{N-1})\), то выполняем присваивание \(\text{ТИН}_{N+1} = \left[a^{N-1}, x^{N-1}\right]\); в противном случае \(\text{ТИН}_{N+1} = \left[x^{N-1}, b^{N-1}\right]\).
\end{enumerate}
В качестве приближенного значения точки минимума \(x^{*}\) может быть принята любая точка последнего ТИН.

Некоторые \textbf{свойства метода Фибоначчи}.

\textit{Утверждение 1}. Для любого \(r = 1, 2, \ldots, N-2\) метод Фибоначчи обладает следующим свойством: одна из точек \(x^{r+1}_{1}\), \(x^{r+1}_{2}\) совпадает с одной из точек \(x^{r}_{1}\), \(x^{r}_{2}\).

\(\blacktriangleleft\) Пусть на \(r\)-ой итерации выполняется \(f(x^{r}_{1}) < f(x^{r}_{2})\), тогда \(\text{ТИН}_{r+1} = \left[a^{r}, x^{r}_{2}\right]\) и \(x^{r}_{1} \in \text{ТИН}_{r+1}\). Рассмотрим точку \(x^{r+1}_{2} = a^{r} + \left|\text{ТИН}_{r+1}\right|\frac{F_{N-(r+1)}}{F_{N-(r+1)+1}} = a^{r} + \left(x^{r}_{2} - a^{r}\right)\frac{F_{N-r-1}}{F_{N-r}}\). Так как \(x^{r}_{2} = a^{r} + \left|\text{ТИН}_{r}\right|\frac{F_{N-r}}{F_{N-r+1}}\), то \(x^{r+1}_{2} = a^{r} + \left(a^{r} + \left|\text{ТИН}_{r}\right|\frac{F_{N-r}}{F_{N-r+1}} - a^{r}\right)\frac{F_{N-r-1}}{F_{N-r}} = a^{r} + \left|\text{ТИН}_{r}\right|\frac{F_{N-r-1}}{F_{N-r+1}} = x^{r}_{1}\) \(\blacktriangleright\)

Доказательство для случая \(f(x^{r}_{1}) > f(x^{r}_{2})\) проводится аналогично. Указанное свойство позволяет на каждой итерации (кроме первой) производить испытания только в одной точке.

\textit{Утверждение 2}. Точки \(x^{r}_{1}\), \(x^{r}_{2}\) расположены симметрично относительно концов ТИН.

\(\blacktriangleleft\) В соответствии с алгоритмом имеем: \(x^{r}_{1} - a^{r} = a^{r} + \left(b^{r} - a^{r}\right)\frac{F_{N-r-1}}{F_{N-r+1}} - a^{r} = \left(b^{r} - a^{r}\right)\frac{F_{N-r-1}}{F_{N-r+1}}\); \(b^{r} - x^{r}_{2} = b^{r} - a^{r} - \left(b^{r} - a^{r}\right)\frac{F_{N-r}}{F_{N-r+1}} = \left(b^{r} - a^{r}\right)\left(1 - \frac{F_{N-r}}{F_{N-r+1}}\right) = \left(b^{r} - a^{r}\right)\left(\frac{F_{N-r+1} - F_{N-r}}{F_{N-r+1}}\right)\). Так как из определения чисел Фибоначчи следует, что \(F_{N-r} = F_{N-r+1} - F_{N-r-1}\), второе выражение можно записать как \(b^{r} - x^{r}_{2} = \left(b^{r} - a^{r}\right)\frac{F_{N-r-1}}{F_{N-r+1}}\). Получили, что \(x^{r}_{1} - a^{r} = b^{r} - x^{r}_{2}  \blacktriangleright\)

\textit{Утверждение 3}. В результате любой итерации \(r = 1, 2, \ldots, N-2\) длина ТИН уменьшается в \(\frac{F_{N-r}}{F_{N-r+1}}\) раз.

\(\blacktriangleleft\) Из утверждения 2 следует, что \(x^{r}_{2} - a^{r} = b^{r} - x^{r}_{1}\), поэтому достаточно рассмотреть только один из отрезков \(\left[a^{r}, x^{r}_{2}\right]\), \(\left[x^{r}_{1}, b^{r}\right]\). Рассмотрим первый отрезок: \(x^{r}_{2} - a^{r} = a^{r} + \left(b^{r} - a^{r}\right)\frac{F_{N-r}}{F_{N-r+1}} - a^{r} = \left(b^{r} - a^{r}\right)\frac{F_{N-r}}{F_{N-r+1}} \blacktriangleright\)

\textit{Утверждение 4}. Из утверждения 3 и \eqref{eq:num9} следует, что при достаточно больших \(N\) в результате одной итерации длина ТИН уменьшается в \(\tau\) раз.

\textit{Утверждение 5}. В результате N итераций длина ТИН становится равной \(\frac{b-a}{F_{N}}\).

\(\blacktriangleleft\) Действительно, после первой итерации \(\left|\text{ТИН}_{2}\right| = \left(b-a\right)\frac{F_{N-1}}{F_{N}}\), после второй итерации \(\left|\text{ТИН}_{3}\right| = \left(b-a\right)\frac{F_{N-1}}{F_{N}}\frac{F_{N-2}}{F_{N-1}} = \left(b-a\right)\frac{F_{N-2}}{F_{N}}\) и т.д.; после \(\left(N-2\right)\)-ой итерации имеем \(\left|\text{ТИН}_{N-1}\right| = \left(b-a\right)\frac{F_{2}}{F_{N}} = \left(b-a\right)\frac{2}{F_{N}}\), после \(\left(N-1\right)\)-ой итерации длина ТИН не меняется, после N-ой итерации длина ТИН уменьшается ровно в два раза (так как из утверждения 2 и выражения  \(x^{N-1}_{1} = x^{N-1}_{2} = x^{N-1}\) следует, что \(x^{N-1}\) делит ТИН пополам): \(\left|\text{ТИН}_{N+1}\right| = \left(b-a\right)\frac{2}{F_{N}} / 2 = \frac{b-a}{F_{N}} \blacktriangleright\)

Метод Фибоначчи является достаточно эффективным (см. раздел \ref{sec:EffectOneVarMethods}) методом одномерной оптимизации, однако в нем доставляет неудобство тот факт, что после выбора значения параметра \(N\) следует обязательно сделать \(N-1\) итераций, без возможности остановки даже в том случае, когда длина очередного ТИН стала меньше заданной точности решения. От этого недостатка можно избавиться следующим образом: из \eqref{eq:num9} следует, что отношение соседних чисел Фибоначчи примерно постоянно, следовательно, на каждой итерации можно выбирать экспериментальные точки так, чтобы они делили ТИН в одном и том же отношении \(\tau\), которое не зависит от \(N\). Эти рассуждения ложатся в основу метода золотого сечения.

\subsubsection{Метод золотого сечения}
Метод золотого сечения является почти таким же эффективным, как метод Фибоначчи, но позволяет остановить вычисления на любой итерации. Определение золотого сечения дается следующим образом: говорят, что точка \(c\) выполняет золотое сечение отрезка \(\left[a, b\right]\), если \(\frac{c-a}{b-a} = \tau\).

Из определения золотого сечения следует, что \(\frac{b-c}{b-a} = \frac{\left(b-a\right)-\left(c-a\right)}{b-a} = 1 -\frac{c-a}{b-a} = 1 - \tau\).

\textbf{Алгоритм метода}:
\begin{enumerate}
\item Выполняем присваивание \(r = 1, a^{1} = a, b^{1} = b, \text{ТИН}_{1} = \left[a^{1}, b^{1}\right]\).
\item Вычисляем величины \(x^{r}_{1} = b^{r} - \left(b^{r}-a^{r}\right)\tau\), \(x^{r}_{2} = a^{r} + \left(b^{r}-a^{r}\right)\tau\).
\item Вычисляем значения \(f(x^{r}_{1})\) и \(f(x^{r}_{2})\).
\item Если \(f(x^{r}_{1}) < f(x^{r}_{2})\), то выполняем присваивание \(a^{r+1} = a^{r}\), \(b^{r+1} = x^{r}_{2}\); в противном случае \(a^{r+1} = x^{r}_{1}\), \(b^{r+1} = b^{r}\). В обоих случаях \(\text{ТИН}_{r+1} = \left[a^{r+1}, b^{r+1}\right]\).
\item Если \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), то заканчиваем вычисления; иначе выполняем присваивание \(r = r + 1\) и переходим к шагу 2.
\end{enumerate}
В качестве приближенного значения точки минимума \(x^{*}\) может быть принята любая точка последнего ТИН.

Некоторые \textbf{свойства метода золотого сечения}.

\textit{Утверждение 1}. Для любого \(r \geq 1\) метод золотого сечения обладает следующим свойством: одна из точек \(x^{r+1}_{1}\), \(x^{r+1}_{2}\) совпадает с одной из точек \(x^{r}_{1}\), \(x^{r}_{2}\).

\(\blacktriangleleft\) Пусть на \(r\)-ой итерации выполняется \(f(x^{r}_{1}) < f(x^{r}_{2})\), тогда \(\text{ТИН}_{r+1} = \left[a^{r}, x^{r}_{2}\right]\) и \(x^{r}_{1} \in \text{ТИН}_{r+1}\). Чтобы доказать справедливость утверждения, нужно показать, что верно соотношение \(\frac{x^{r}_{1}-a^{r}}{x^{r}_{2}-a^{r}} = \tau\). Из 2-го шага алгоритма следует, что \(b^{r}-x^{r}_{1} = \left(b^{r}-a^{r}\right)\tau \Rightarrow b^{r}-x^{r}_{1}-a^{r}+a^{r} = \left(b^{r}-a^{r}\right)\tau \Rightarrow \left(b^{r}-a^{r}\right)-\left(x^{r}_{1}-a^{r}\right) = \left(b^{r}-a^{r}\right)\tau \Rightarrow x^{r}_{1} - a^{r} = \left(b^{r}-a^{r}\right)\left(1-\tau\right)\). Аналогично имеем \(x^{r}_{2}-a^{r} = \left(b^{r}-a^{r}\right)\tau\). Разделив первый из полученных результатов на второй, получаем \(\frac{x^{r}_{1}-a^{r}}{x^{r}_{2}-a^{r}} = \frac{1-\tau}{\tau}\). Но из \eqref{eq:num7} следует, что \(1-\tau = \tau^{2}\), в результате чего имеем \(\frac{x^{r}_{1}-a^{r}}{x^{r}_{2}-a^{r}} = \frac{1-\tau}{\tau} = \frac{\tau^{2}}{\tau} = \tau \blacktriangleright\)

Доказательство для случая \(f(x^{r}_{1}) > f(x^{r}_{2})\) проводится аналогично. Указанное свойство позволяет на каждой итерации (кроме первой) производить испытания только в одной точке.

\textit{Утверждение 2}. Точки \(x^{r}_{1}\), \(x^{r}_{2}\) расположены симметрично относительно концов ТИН.

\(\blacktriangleleft\) Из 2-го шага алгоритма следует, что точка \(x^{r}_{1}\) отстоит от точки \(b^{r}\) на величину \(\left(b^{r}-a^{r}\right)\tau\); точка \(x^{r}_{2}\) отстоит от точки \(a^{r}\) на ту же величину. \(\blacktriangleright\)

\textit{Утверждение 3}. Поскольку после каждой итерации длина ТИН уменьшается в \(\tau\) раз, можно априорно оценить количество итераций по заданной точности решения. Действительно, после первой итерации \(\left|\text{ТИН}_{2}\right| = \left(b-a\right)\tau\), после второй итерации \(\left|\text{ТИН}_{3}\right| = \left(b-a\right)\tau\tau = \left(b-a\right)\tau^{2}\) и т.д. Тогда после \(r\)-ой итерации имеем \(\left|\text{ТИН}_{r+1}\right| = \left(b-a\right)\tau^{r}\). Но, так как условие окончания поиска \(\left|\text{ТИН}_{r+1}\right| \leq \epsilon_{x}\), получаем \(\left(b-a\right)\tau^{r} \leq \epsilon_{x}\). Заменив знак неравенства на равенство и выразив \(r\), получим оценку количества итераций.

\subsection{Сравнение эффективности методов, сокращающих ТИН}
\label{sec:EffectOneVarMethods}
Обозначим через \(\Phi\) класс непрерывных унимодальных одномерных функций. Пусть множество рассматриваемых методов поиска есть \(\left\{A_{1}, A_{2}, A_{3}, A_{4}\right\}\), где
\begin{itemize}
\item \(A_{1}\) - метод равномерного поиска;
\item \(A_{2}\) - метод дихотомии;
\item \(A_{3}\) - метод Фибоначчи;
\item \(A_{4}\) - метод золотого сечения.
\end{itemize}
В качестве критерия оптимальности указанных методов на классе функций \(\Phi\) будем использовать максимальную длину ТИН после \(m\) \textbf{испытаний}:
\begin{equation}
\label{eq:num10}
W(A) = \underset{f \in \Phi}{\max} \left|\text{ТИН}_{m}(f, A)\right|
\end{equation}
Использование подобного критерия обусловлено тем, что при решении оптимизационной задачи зачастую требуется минимизировать число испытаний (это уже обсуждалось в разделе \ref{sec:ClassMetOpt}). Но, поскольку в предыдущем разделе длина ТИН связывалась с количеством итераций (а, как было показано, почти во всех методах число итераций не совпадает с числом испытаний), необходимо в выведенных формулах сделать переход от итераций к испытаниям.

При рассмотрении метода равномерного поиска было показано, что после каждой итерации длина ТИН уменьшается в \(\frac{N}{2}\) раз, а количество испытаний на каждой итерации \(m = N + 1\). Следовательно, \(W(A_{1}) = \frac{2}{N}\left(b-a\right) = \frac{2}{m-1}\left(b-a\right)\).

При рассмотрении метода дихотомии было показано, что после каждой итерации длина ТИН уменьшается в 2 раза, количество испытаний на каждой итерации равно 2, поэтому \(m = 2N\). Следовательно, \(W(A_{2}) = \frac{b-a}{2^{N}} = \frac{b-a}{2^{m/2}}\).

При рассмотрении метода Фибоначчи было показано, что в результате \(N\) итераций длина ТИН становится равной \(\frac{b-a}{F_{N}}\), а количество испытаний \(m = N + 1\) (на первой итерации два испытания, дальше по одному испытанию на каждой итерации). Следовательно, \(W(A_{3}) = \frac{b-a}{F_{m - 1}}\).

При рассмотрении метода золотого сечения было показано, что в результате \(N\) итераций длина ТИН становится равной \(\left(b-a\right)\tau^{N}\), а количество испытаний \(m = N + 1\) (на первой итерации два испытания, дальше по одному испытанию на каждой итерации). Следовательно, \(W(A_{4}) = \left(b-a\right)\tau^{m-1}\).

Пользуясь полученными результатами, сравним метод дихотомии и метод Фибоначчи при числе испытаний \(m = 14\): \(\frac{W(A_{2})}{W(A_{3})} = \frac{F_{m-1}}{2^{m/2}} = \frac{F_{13}}{2^{7}} = \frac{233}{128} \approx 1,82\). Видно, что метод Фибоначчи почти в два раза эффективнее метода дихотомии.

\subsection{Методы полиномиальной аппроксимации}
Если при решении оптимизационной задачи была получена информация о том, что целевая функция является достаточно гладкой в некоторой окрестности экстремума, то в этой окрестности ее можно достаточно точно заменить (аппроксимировать) полиномом некоторого порядка, после чего использовать для нахождения экстремума этот полином.

Качество аппроксимации может быть повышено двумя способами:
\begin{itemize}
\item Увеличение степени аппроксимирующего полинома;
\item Уменьшение сетки аппроксимации.
\end{itemize}
Второй способ является более предпочтительным, так как построение полинома порядка выше трех - достаточно сложная задача.

\subsubsection{Метод квадратичной аппроксимации}
В данном методе целевая функция приближенно заменяется параболой, проходящей через три известные точки \(\left(x_{i}, y_{i}\right)\), где \(y_{i} = f(x_{i}),\ i=1,2,3\).

Построим полином следующего вида: \(q(x) = a_{0} + a_{1}(x-x_{1}) + a_{2}(x-x_{1})(x-x_{2})\). Необходимо выбрать \(a_{i},\ i=1,2,3\) таким образом, чтобы \(q(x_{i}) = y_{i},\ i=1,2,3\).

Подставив в полином \(x_{1}\): \(q(x_{1}) = a_{0}\), следовательно, \(a_{0} = y_{1}\). Подставим в полином \(x_{2}\): \(q(x_{2}) = a_{0} + a_{1}(x_{2}-x_{1}) = y_{2}\), следовательно, \(a_{1} = \frac{y_{2} - y_{1}}{x_{2} - x_{1}}\). Подставим в полином \(x_{3}\): \(q(x_{3}) = a_{0} + a_{1}(x_{3}-x_{1}) + a_{2}(x_{3} - x_{1})(x_{3}-x_{2}) = y_{3}\), следовательно, \(a_{2} = \frac{1}{x_{3} - x_{2}}\left(\frac{y_{3}-y_{1}}{x_{3}-x_{1}} - \frac{y_{2}-y_{1}}{x_{2}-x_{1}}\right)\).

Найдем экстремум классическим методом, взяв производную: \(q'(x) = a_{1} + a_{2}(x-x_{1}) + a_{2}(x-x_{2}) = 0\), откуда \(x^{*} = \frac{x_{1} + x_{2}}{2} - \frac{a_{1}}{2a_{2}}\).\\

\textit{Пример}. Найдем с помощью квадратичной аппроксимации экстремум функции \(f(x) = \sin(x) + \cos(x)\) на отрезке \([-1; 1]\). В качестве точек аппроксимации возьмем \(x_{1} = -1,\ x_{2} = 0,\ x_{3} = 1\), и, соответственно, \(y_{1} \approx -0,3,\ y_{2} = 1,\ y_{3} = 1,38\). Для определения оптимальной точки нужно знать коэффициенты \(a_{1}\) и \(a_{2}\). Найдем их: \(a_{1} = \frac{y_{2} - y_{1}}{x_{2} - x_{1}} \approx 1,3\); \(a_{2} = \frac{1}{x_{3} - x_{2}}\left(\frac{y_{3}-y_{1}}{x_{3}-x_{1}} - a_{1}\right) \approx -0,46\). Тогда \(x^{*} = \frac{x_{1} + x_{2}}{2} - \frac{a_{1}}{2a_{2}} \approx 0,91\). Из рисунка \ref{fig:approx_example} видно, что построенный аппроксимационный полином достаточно точно приближает целевую функцию.

\begin{figure}[ht]
\center{\includegraphics[width=0.8\linewidth]{approx_example.png}}
\caption{Целевая функция и аппроксимирующий полином}
\label{fig:approx_example}
\end{figure}

Подобные расчеты можно повторять для уточнения точки экстремума, на каждой итерации заново выбирая точки \(x_{i},\ i=1,2,3\) каким-либо образом. Например, можно найденную на предыдущем шаге точку оптимума обозначать как \(x_{2}\), а в качестве точек \(x_{1}\) и \(x_{3}\) брать те использовавшиеся на предыдущем шаге точки, между которыми оказалась точка оптимума. Например, для примера выше \(x_{1} = -1,\ x_{2} = 0,\ x_{3} = 1\) и \(x^{*} \approx 0,91\). Тогда на следующем шаге можно положить \(x_{1} = 0,\ x_{2} \approx 0,91 ,\ x_{3} = 1\). Однако это не всегда возможно: скажем, вполне возможна ситуация, когда \(x^{*} \notin [x_{1}; x_{3}]\); решить эту проблему помогает метод Пауэлла.

\subsubsection{Метод Пауэлла}
\begin{enumerate}
\item Выбираем начальную точку \(x_{1}\), величину шага \(\Delta_{x}\) и \(\epsilon_{1},\ \epsilon_{2}\) - малые положительные числа.
\item Выполняем \(x_{2} = x_{1} + \Delta_{x}\).
\item Вычисляем \(f(x_{1})\) и \(f(x_{2})\). Если \(f(x_{1}) > f(x_{2})\), то \(x_{3} = x_{1} + 2\Delta_{x}\); в противном случае \(x_{3} = x_{1} - \Delta_{x}\).
\item Вычисляем \(f(x_{3})\) и находим \(f_{min} = \min\left\{f(x_{1}),f(x_{2}),f(x_{3})\right\}\); \(x_{min} = \left\{x_{i} | f(x_{i}) = f_{min}\right\}\).
\item По \(x_{1},\ x_{2}.\ x_{3}\) вычисляем \(x^{*}\) и \(f(x^{*})\), пользуясь формулами квадратичной аппроксимации. Если \(a_{2}=0\), то результатом аппроксимации является не парабола, а прямая; в этом случае следует положить \(x_{1}=x_{min}\) и перейти к шагу 2.
\item Проверяем условия окончания поиска: \(\left|\frac{f_{min} - f(x^{*})}{f(x^{*})}\right| \leq \epsilon_{1}\), \(\left|\frac{x_{min} - x^{*}}{x^{*}}\right| \leq \epsilon_{2}\).
\begin{itemize}
\item Если оба условия выполняются, останавливаем поиск; точка оптимума - \(x^{*}\);
\item Если хотя бы одно условие не выполняется и \(x^{*} \in [x_{1}; x_{3}]\) (или \(x^{*} \in [x_{3}; x_{2}]\) - в зависимости от выбранного на шаге 3 направления поиска), то выбираем <<наилучшую точку>> (либо \(x_{min}\), либо \(x^{*}\)) и две использовавшиеся точки по обе стороны от нее. Обозначаем эти точки в естественном порядке \(x_{1},\ x_{2},\ x_{3}\) и переходим к шагу 5;
\item Если хотя бы одно условие не выполняется и \(x^{*} \notin [x_{1}; x_{3}]\) (или \(x^{*} \notin [x_{3}; x_{2}]\) - в зависимости от выбранного на шаге 3 направления поиска), то обозначаем \(x_{1}=x_{min}\) и переходим к шагу 2.
\end{itemize}
\end{enumerate}

\subsection{Методы, использующие производные}
Если целевая функция достаточно просто дифференцируется и вычисление значения производной не представляет значительных сложностей, то целесообразно воспользоваться этим обстоятельством для поиска экстремума. Общая идея излагаемых ниже методов состоит в численном решении уравнения классического метода оптимизации - \(f'(x) = 0\).

\subsubsection{Метод средней точки}
Данный метод очень схож с методом дихотомии: определяются две точки \(L\) и \(R\), в которых производная целевой функции имеет разные знаки (например, \(f'(L) < 0,\ f'(R) > 0\)). Тогда точка экстремума, в которой \(f'(x) = 0\), будет находиться на отрезке \([L, R]\). Полагаем \(Z = \frac{L+R}{2}\) и вычисляем \(f'(Z)\), после чего исключаем из рассмотрения один из отрезков (\([L, Z]\) или \([Z, R]\)), на краях которого знаки производной совпадают. Процесс можно повторять до достижения требуемой точности: \(\left|R-L\right| \leq \epsilon\) или \(\left|f'(Z)\right| \leq \epsilon\).

\subsubsection{Метод Ньютона (касательных)}
Если целевая функция имеет непрерывные и сохраняющие определенные знаки производные вплоть до третьей включительно на некотором отрезке \([a, b]\), причем первая производная имеет разные знаки на концах этого отрезка (то есть \(f'(a)f'(b) < 0\)), то, исходя из начального приближения \(x_{0} \in [a, b]\), удовлетворяющего условию \(f'(x_{0})f'''(x_{0}) > 0\), можно вычислить с любой точностью единственный корень уравнения \(f'(x) = 0\).

Проведем через точку \((x_{0}, y_{0})\) касательную. Уравнение такой касательной записывается как
\begin{equation}
\label{eq:num11}
y = f(x_{0}) + f'(x_{0})(x-x_{0})
\end{equation}

Поскольку мы ищем решение уравнения \(f'(x) = 0\), заменим в \eqref{eq:num11} \(f\) на \(f'\) и \(f'\) на \(f''\), после чего найдем точку пересечения касательной с осью абсцисс (\(y = 0\)): \(f'(x_{0}) + f''(x_{0})(x-x_{0}) = 0\). Из полученного соотношения выразим \(x\): \(x = x_{0} - \frac{f'(x_{0})}{f''(x_{0})}\). Тогда можно построить итерационный процесс:
\begin{equation}
\label{eq:num12}
x_{k+1} = x_{k} - \frac{f'(x_{k})}{f''(x_{k})}
\end{equation}

Геометрическая интерпретация метода приведена на рисунке \ref{fig:newton_example}. Итерационный процесс \eqref{eq:num12} заканчивается, когда \(\left|f'(x_{k+1})\right| \leq \epsilon\) или \(\left|x_{k+1}-x_{k}\right| \leq \epsilon\).

\subsubsection{Метод секущих (хорд)}
Метод секущих получается из метода касательных заменой \(f''(x_{k})\) в \eqref{eq:num12} разностным приближением: \(f''(x_{k}) \approx \frac{f'(x_{k})-f'(x_{k-1})}{x_{k}-x_{k-1}}\). В результате получим формулу итерационного процесса:
\begin{equation}
\label{eq:num13}
x_{k+1}=x_{k}-\frac{x_{k}-x_{k-1}}{f'(x_{k})-f'(x_{k-1})}f'(x_{k})
\end{equation}

Методом хорд называют метод секущих в том случае, когда один из концов отрезка \([a, b]\) закреплен, т. е. вычисление приближения корня уравнения \(f'(x) = 0\) производят по формулам:
\begin{equation}
\label{eq:num14}
x_{k+1}=x_{k}-\frac{x_{k}-a}{f'(x_{k})-f'(a)}f'(x_{k}),\ x_{0} = b
\end{equation}
либо
\begin{equation}
\label{eq:num15}
x_{k+1}=x_{k}-\frac{x_{k}-b}{f'(x_{k})-f'(b)}f'(x_{k}),\ x_{0} = a
\end{equation}

В качестве \(x_{0}\) в обоих методах выбирают тот конец отрезка, на котором выполняется \(f'(x_{0})f'''(x_{0}) > 0\). Для метода секущих дополнительно нужно определить \(x_{1}\), так как этот метод является двухшаговым; это делается с помощью одной итерации метода хорд (см. \eqref{eq:num14}, \eqref{eq:num15}), а все последующие значения вычисляются с помощью \eqref{eq:num13}.

Геометрическая интерпретация метода приведена на рисунке \ref{fig:sek_example}. Итерационный процесс \eqref{eq:num13} заканчивается, когда \(\left|f'(x_{k+1})\right| \leq \epsilon\) или \(\left|x_{k+1}-x_{k}\right| \leq \epsilon\).

\section{Безусловная оптимизация функций многих переменных}

\subsection{Основные понятия и определения}

\subsubsection{Постановка задачи}
Пусть задана функция \(n\) действительных переменных \(f(\overline{x}) = f(x_{1}, x_{2}, \ldots, x_{n})\), определенная на множестве \(X \in \mathbb{R}^{n}\). Говорят, что функция \(f(\overline{x})\) имеет \textbf{локальный минимум} в точке \(\overline{x}^{*} \in X\), если существует окрестность точки \(\overline{x}^{*}\), такая, что \(f(\overline{x}^{*}) \leq f(\overline{x})\) для любой точки этой окрестности. Аналогично, функция имеет \textbf{глобальный минимум} в точке \(\overline{x}^{*} \in X\), если условие \(f(\overline{x}^{*}) \leq f(\overline{x})\) справедливо для любой \(\overline{x} \in X\).

\subsubsection{Поверхность и линия уровня}
\textbf{Поверхностью уровня} называется геометрическое место точек, где \(f(\overline{x}) = const\). Для функции двух переменных поверхность уровня называется \textbf{линией уровня}.

\subsubsection{Градиент функции многих переменных и его свойства}
Градиентом функции многих переменных называется вектор, составленный из первых частных производных функции по всем переменным:
\begin{equation}
\label{eq:num16}
\nabla f(\overline{x}) = \left(\frac{\partial f}{\partial x_{1}}, \frac{\partial f}{\partial x_{2}}, \ldots, \frac{\partial f}{\partial x_{n}}\right)^{T}
\end{equation}
Свойства градиента:
\begin{enumerate}
\item Градиент функции перпендикулярен поверхности уровня функции \(f(\overline{x})\); в случае функции двух переменных он перпендикулярен касательной к линии уровня.
\item Направление градиента есть направление наиболее быстрого роста функции.
\end{enumerate}

\subsubsection{Матрица Гессе}
Квадратная матрица размера \(n \times n\), состоящая из вторых частных производных функции \(f(\overline{x})\), называется \textbf{матрицей Гессе}:
\begin{equation}
\label{eq:num17}
H(x) = \begin{pmatrix}
\frac{\partial^{2} f}{\partial x^{2}_{1}} & \frac{\partial^{2} f}{\partial x_{1} \partial x_{2}} & \cdots & \frac{\partial^{2} f}{\partial x_{1} \partial x_{n}} \\
\frac{\partial^{2} f}{\partial x_{2} \partial x_{1}} & \frac{\partial^{2} f}{\partial x^{2}_{2}} & \cdots & \frac{\partial^{2} f}{\partial x_{2} \partial x_{n}} \\        
\vdots & \vdots & \ddots & \vdots \\
\frac{\partial^{2} f}{\partial x_{n} \partial x_{1}} & \frac{\partial^{2} f}{\partial x_{n} \partial x_{2}} & \cdots & \frac{\partial^{2} f}{\partial x^{2}_{n}}
\end{pmatrix}
\end{equation}

\subsubsection{Критерий Сильвестра}
Матрица является \textbf{положительно определенной}, если все ее диагональные миноры положительно определены; и является \textbf{отрицательно определенной}, если все ее диагональные миноры чередуют знак, начиная со знака <<минус>>.

\subsubsection{Понятие стационарности}
Точка \(\overline{x}^{*}\) называется \textbf{стационарной}, если \(\nabla f(\overline{x}^{*}) = \overline{0}\) (следует понимать, что \(\overline{0}\) - нулевой вектор).

\subsubsection{Условия локальной оптимальности}
\textbf{Необходимое условие} локальной оптимальности. 

Если \(\overline{x}^{*}\) - точка, в которой достигается локальный экстремум, то выполняется условие стационарности \(\nabla f(\overline{x}^{*}) = \overline{0}\) (обратное в общем случае неверно!).

\textbf{Достаточное условие} локальной оптимальности.

Пусть в точке \(\overline{x}^{*}\ f(\overline{x})\) дважды дифференцируема и выполняется необходимое условие локальной оптимальности. Тогда, если матрица Гессе для указанной точки положительно определена, то \(\overline{x}^{*}\) - точка локального минимума; если матрица Гессе для указанной точки отрицательно определена, то \(\overline{x}^{*}\) - точка локального максимума; если матрица Гессе для указанной точки не определена ни положительно, ни отрицательно, то \(\overline{x}^{*}\) - седловая точка.\\

\textit{Пример}. Попробуем аналитически определить точку экстремума для функции \(f(x, y) = 2x^{2} + 2y^{2} + 2xy + 20x + 10y + 10\). Для этого посчитаем частные производные и составим вектор градиента: \(\frac{\partial f}{\partial x} = 4x + 2y + 20,\ \frac{\partial f}{\partial y} = 4y + 2x + 10, \ \nabla f = \left(4x + 2y + 20, 4y + 2x + 10\right)^{T}\). Найдем стационарную точку из условия \(\nabla f = (0, 0)^{T}\), приравняв частные производные к нулю. в результате решения системы уравнений получим \(x = -5, y = 0\). Теперь построим матрицу Гессе: \(H = \begin{pmatrix} \frac{\partial^{2} f}{\partial x^{2}} & \frac{\partial^{2} f}{\partial x \partial y} \\ \frac{\partial^{2} f}{\partial y \partial x} & \frac{\partial^{2} f}{\partial y^{2}} \end{pmatrix} = \begin{pmatrix} 4 & 2 \\ 2 & 4 \end{pmatrix}\). Все диагональные миноры этой матрицы положительно определены, следовательно, найденная точка является точкой минимума. График с изображением линий уровня в окрестности найденной точки это подтверждает (рис. \ref{fig:fmp_analysis_example}).

\begin{figure}[ht]
\center{\includegraphics[width=0.8\linewidth]{fmp_analysis_example.png}}
\caption{Линии уровня в окрестности точки оптимума}
\label{fig:fmp_analysis_example}
\end{figure}

Однако, как уже было сказано, вычислять производные при решении задач оптимизации удается не всегда. Поэтому сначала рассмотрим ряд методов, позволяющих находить экстремумы функций многих переменных без вычисления частных производных.

\subsection{Простейшие поисковые методы}

\subsubsection{Метод Гаусса-Зейделя (покоординатного спуска)}
В методе Гаусса-Зейделя на каждом шаге ищут экстремум целевой функции, фиксируя все переменные, кроме какой-либо одной; значения фиксированных переменных полагаются постоянными. Поиск экстремума при одной свободной переменной выполняют любым методом одномерной оптимизации. Таким образом, в методе Гаусса-Зейделя задача многомерной оптимизации сводится к задаче одномерной оптимизации.

\textbf{Алгоритм метода:}
\begin{enumerate}
\item Выбираем начальное приближение \(\overline{x}_{0} = (x^{(0)}_{1}, x^{(0)}_{2}, \ldots, x^{(0)}_{n})\); устанавливаем \(i = 0\).
\item Фиксируем все координаты, кроме первой, и проводим операцию одномерного поиска \(f(x_{1}) = f(x_{1}, x^{(i)}_{2}, x^{(i)}_{3}, \ldots, x^{(i)}_{n})\); в результате получаем \(\overline{x}^{(1)}_{i} = (x^{*}_{1}, x^{(i)}_{2}, x^{(i)}_{3}, \ldots, x^{(i)}_{n})\).
\item Фиксируем в точке \(\overline{x}^{(1)}_{i}\) все координаты, кроме второй, и повторяем одномерный поиск \(f(x_{2}) = f(x^{*}_{1}, x_{2}, x^{(i)}_{3}, \ldots, x^{(i)}_{n})\); в результате получаем \(\overline{x}^{(2)}_{i} = (x^{*}_{1}, x^{*}_{2}, x^{(i)}_{3}, \ldots, x^{(i)}_{n})\) и т.д. Продолжаем указанный процесс для всех \(n\) координат, пока не получим \(\overline{x}^{(n)}_{i} = (x^{*}_{1}, x^{*}_{2}, x^{*}_{3}, \ldots, x^{*}_{n})\).
\item Обозначаем \(\overline{x}^{(n)}_{i} = \overline{x}_{i+1}\) и проверяем условие окончания поиска \(\left\|\overline{x}_{i+1} - \overline{x}_{i}\right\| \leq \epsilon\). Если условие окончания поиска не выполняется, устанавливаем \(i = i + 1\) и переходим к шагу 2; в противном случае принимаем за точку оптимума \(\overline{x}_{i+1}\).
\end{enumerate}

Метод обладает тем недостатком, что, в случае так называемой <<овражной>> функции, оптимум никогда не будет достигнут при попадании точки в <<овраг>>.

\subsubsection{Метод Хука-Дживса (конфигураций)}
Этот метод можно рассматривать как модификацию метода Гаусса-Зейделя. Идея состоит в том, что из точки начального приближения выполняется одна итерация по методу Гаусса-Зейделя (<<исследующий поиск>>), а дальнейший поиск (<<поиск по образцу>>) проводят вдоль прямой, соединяющей точку начального приближения и точку, полученную во время исследующего поиска. Когда на этой прямой будет найдена точка, значение целевой функции в которой в известном смысле оптимально, из нее снова выполняют одну итерацию по методу Гаусса-Зейделя и т.д.

\textbf{Алгоритм метода:}
\begin{enumerate}
\item Выбираем начальное приближение \(\overline{x}_{0} = (x^{(0)}_{1}, x^{(0)}_{2}, \ldots, x^{(0)}_{n})\); устанавливаем \(i = 0\).
\item Исследующий поиск: выполняем одну итерацию по методу Гаусса-Зейделя, получаем точку \(\overline{x}_{i + 1}\). Проверяем условие окончания поиска \(\left\|\overline{x}_{i+1} - \overline{x}_{i}\right\| \leq \epsilon\). Если оно не выполняется, переходим к шагу 3; в противном случае принимаем за точку оптимума \(\overline{x}_{i+1}\).
\item Поиск по образцу: соединяем точки \(\overline{x}_{i + 1}\) и \(\overline{x}_{i}\) прямой, после чего двигаемся вдоль полученного направления с некоторым шагом \(k\): \(\overline{x}_{j + 1} = \overline{x}_{j} + k(\overline{x}_{j} - \overline{x}_{j - 1})\) (на первой итерации поиска по образцу \(j = i\)). После каждого определения новой точки проверяем условие окончания поиска \(\left\|\overline{x}_{j+1} - \overline{x}_{j}\right\| \leq \epsilon\). Если оно не выполняется, то устанавливаем \(j = j + 1\) и повторяем поиск по образцу; в противном случае принимаем за точку оптимума \(\overline{x}_{j+1}\).
\item Если на шаге исследующего поиска найдена <<оптимальная>> точка на выбранном направлении, и условие остановки не выполнено, то полагаем \(i = j\) и возвращаемся к исследующему поиску (шаг 2).
\end{enumerate}

За счет возможности варьирования параметра \(k\) данный метод лучше метода Гаусса-Зейделя в смысле преодоления <<оврагов>>, однако полностью исключить <<застревание в овраге>> все равно невозможно.

\subsection{Симплексные методы}
\textbf{Симплексом} в пространстве \(n\) переменных называется выпуклый многогранник, имеющий \(n + 1\) вершину: в пространстве 2-х переменных - это треугольник, в пространстве 3-х переменных - тетраэдр и т.д.

\subsubsection{Обычный симплекс-метод}
В обычном симплекс-методе используется правильный симплекс, все ребра которого равны. Для наглядности рассмотрим идею симплекс-метода для случая 2-х переменных.

Выбираем начальный симплекс с координатами вершин \(\overline{x}_{1},\ \overline{x}_{2},\ \overline{x}_{3}\). Размещение этого симплекса в пространстве может быть осуществлено двумя путями.
\begin{enumerate}
\item Одна из вершин симплекса помещается в начало координат, а остальные располагаются так, чтобы ребра, выходящее из первой вершины, образовывали одинаковые углы с соответствующими координатными осями (рис. \ref{fig:simplex_1}). Координаты вершин для случая единичного симплекса приведены в таблице \ref{tab:simplex_1_2}.

\begin{minipage}{\textwidth}
  \begin{minipage}{0.49\textwidth}
    \centering
    \includegraphics[width=0.7\linewidth]{simplex_1.png}
    \captionof{figure}{Симплекс с вершиной в начале координат}
    \label{fig:simplex_1}
  \end{minipage}
  \hfill
  \begin{minipage}{0.49\textwidth}
    \centering
    \captionsetup{justification=raggedleft}
    \captionof{table}{\hspace{18mm}~}
    \label{tab:simplex_1_2}
    \begin{tabular}{|c|c|c|}
      \hline
      Вершина & \(x_{1}\) & \(x_{2}\)\\
      \hline
      \(\overline{x}^{(1)}\) & 0 & 0\\
      \hline
      \(\overline{x}^{(2)}\) & \(\frac{\sqrt{3} + 1}{2\sqrt{2}}\) & \(\frac{\sqrt{3} - 1}{2\sqrt{2}}\)\\
      \hline
      \(\overline{x}^{(3)}\) & \(\frac{\sqrt{3} - 1}{2\sqrt{2}}\) & \(\frac{\sqrt{3} + 1}{2\sqrt{2}}\)\\
      \hline
    \end{tabular}
  \end{minipage}
\end{minipage}

Введя параметры \(P = \frac{1}{n\sqrt{2}}(\sqrt{n+1} + n - 1)\) и \(Q = \frac{1}{n\sqrt{2}}(\sqrt{n+1} - 1)\), можно расширить таблицу \ref{tab:simplex_1_2} для случая единичного симплекса в пространстве \(n\) переменных (таблица \ref{tab:simplex_1_n}).

\begin{table}
\begin{center}
\captionsetup{justification=raggedleft}
\caption{~~~~~~~~~~}
\label{tab:simplex_1_n}
    \begin{tabular}{|c|c|c|c|c|c|}
      \hline
      № вершины & \(x_{1}\) & \(x_{2}\) & \(x_{3}\) & \(\ldots\) & \(x_{n}\)\\
      \hline
      1 & 0 & 0 & 0 & \(\ldots\) & 0\\
      \hline
      2 & \(P\) & \(Q\) & \(Q\) & \(\ldots\) & \(Q\)\\
      \hline
      3 & \(Q\) & \(P\) & \(Q\) & \(\ldots\) & \(Q\)\\
      \hline
      \(\ldots\) & \(\ldots\) & \(\ldots\) & \(\ldots\) & \(\ldots\) & \(\ldots\)\\
      \hline
      \(n+1\) & \(Q\) & \(Q\) & \(Q\) & \(\ldots\) & \(P\)\\
      \hline
    \end{tabular}
\end{center}
\end{table}

\item Центр симплекса помещается в начало координат, а \((n+1)\)-я вершина на ось \(x_{n}\); остальные располагаются симметрично относительно координатных осей (рис. \ref{fig:simplex_2}). Координаты вершин для случая единичного симплекса приведены в таблице \ref{tab:simplex_2_2}.

\begin{minipage}{\textwidth}
  \begin{minipage}{0.49\textwidth}
    \centering
    \includegraphics[width=0.7\linewidth]{simplex_2.png}
    \captionof{figure}{Симплекс с вершиной в начале координат}
    \label{fig:simplex_2}
  \end{minipage}
  \hfill
  \begin{minipage}{0.49\textwidth}
    \centering
    \captionsetup{justification=raggedleft}
    \captionof{table}{~~~~~~~~~~}
    \label{tab:simplex_2_2}
    \begin{tabular}{|c|c|c|}
      \hline
      Вершина & \(x_{1}\) & \(x_{2}\)\\
      \hline
      \(\overline{x}^{(1)}\) & \(-\frac{1}{2}\) & \(-\frac{1}{2\sqrt{3}}\)\\
      \hline
      \(\overline{x}^{(2)}\) & \(\frac{1}{2}\) & \(-\frac{1}{2\sqrt{3}}\)\\
      \hline
      \(\overline{x}^{(3)}\) & 0 & \(\frac{1}{\sqrt{3}}\)\\
      \hline
    \end{tabular}
  \end{minipage}
\end{minipage}

Введя параметры \(R_{i} = \frac{1}{\sqrt{2i(i+1)}}\) и \(V_{i} = \sqrt{\frac{i}{2(i+1)}}\), можно расширить таблицу \ref{tab:simplex_2_2} для случая единичного симплекса в пространстве \(n\) переменных (таблица \ref{tab:simplex_2_n}).

\begin{table}[h]
\begin{center}
\captionsetup{justification=raggedleft}
\caption{~~~~~~~~~~~~~~~~~~~~}
\label{tab:simplex_2_n}
    \begin{tabular}{|c|c|c|c|c|c|}
      \hline
      № вершины & \(x_{1}\) & \(x_{2}\) & \(x_{3}\) & \(\ldots\) & \(x_{n}\)\\
      \hline
      1 & \(-R_{1}\) & \(-R_{2}\) & \(-R_{3}\) & \(\ldots\) & \(-R_{n}\)\\
      \hline
      2 & \(V_{1}\) & \(-R_{2}\) & \(-R_{3}\) & \(\ldots\) & \(-R_{n}\)\\
      \hline
      3 & 0 & \(V_{2}\) & \(-R_{3}\) & \(\ldots\) & \(-R_{n}\)\\
      \hline
      4 & 0 & 0 & \(V_{3}\) & \(\ldots\) & \(-R_{n}\)\\
      \hline
      \(\ldots\) & \(\ldots\) & \(\ldots\) & \(\ldots\) & \(\ldots\) & \(\ldots\)\\
      \hline
      \(n+1\) & 0 & 0 & 0 & \(\ldots\) & \(-R_{n}\)\\
      \hline
    \end{tabular}
\end{center}
\end{table}

\end{enumerate}

\newpage

Как уже упоминалось, все формулы выше даны для случая единичного симплекса. Для произвольной длины ребра каждую формулу нужно дополнительно умножить на желаемую длину ребра.

Если поиск осуществляется не из начала координат, а из начальной точки \(\overline{x}_{0}\), то к координатам вершин симплекса необходимо прибавить координаты начальной точки.

\textbf{Алгоритм метода:}
\begin{enumerate}
\item Выбираем начальное приближение \(\overline{x}_{0}\) и строим правильный симплекс одним из предложенных способов.
\item В вершинах симплекса вычисляем значения целевой функции, выбираем из них <<худшее>> и через центр тяжести противолежащей грани строим новую вершину симплекса, симметричную <<худшей>> вершине (рис. \ref{fig:simplex_example}). Например, если <<худшая>> вершина - \(\overline{x}_{1}\), то \(\overline{x}_{\text{ц.т.}} = \frac{\overline{x}_{2} + \overline{x}_{3}}{2}\) и новая вершина \(\overline{x}_{4} = \overline{x}_{\text{ц.т.}} + (\overline{x}_{\text{ц.т.}} - \overline{x}_{1}) = \overline{x}_{2} + \overline{x}_{3} - \overline{x}_{1}\).
\item В результате отображения <<худшей>> точки получаем новый симплекс, причем в двух его вершинах значение целевой функции уже известно. Продолжаем описанный процесс до тех пор, пока он не зациклится (отображенная вершина становится <<худшей>>). В этом случае смотрим на длину ребра симплекса - если она меньше заданной точности, то останавливаем процесс поиска; в противном случае уменьшаем размер симплекса и продолжаем поиск.
\end{enumerate}

\begin{figure}[ht]
\center{\includegraphics[width=0.5\linewidth]{simplex_example.png}}
\caption{Отображение точки с <<худшим>> значением функции}
\label{fig:simplex_example}
\end{figure}

\clearpage

\chapter{Линейное программирование}

\clearpage

\chapter{Комбинаторная оптимизация}

\clearpage

\chapter{Стохастическая оптимизация}

\clearpage

\addcontentsline{toc}{chapter}{Литература} % список литературы автоматически в оглавление не попадает
\bibliography{biblio/doc}

\end{document}